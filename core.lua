-- EASE CORE - by Alchael
ac = {}
ac.actions = {
    Addle = 7560,
    Adloquium = 185,
    Aero = 121,
    Aethercharge = 25800,
    Aetherflow = 166,
    ApexArrow = 16496,
    ArmoftheDestroyer = 62,
    ArmysPaeon = 116,
    ArtofWar = 16539,
    Ascend = 3603,
    AspectedBenefic = 3595,
    AspectedHelios = 3601,
    Barrage = 107,
    BattleLitany = 3557,
    BattleVoice = 118,
    Benediction = 140,
    Benefic = 3594,
    Benefic2 = 3610,
    Berserk = 38,
    Bio = 17864,
    BlastArrow = 25784,
    Blizzard = 142,
    Blizzard2 = 25793,
    Blizzard3 = 154,
    Bloodbath = 7542,
    Bloodletter = 110,
    Bootshine = 53,
    Bulwark = 22,
    BurstShot = 97,
    CausticBite = 100,
    ChaosThrust = 88,
    CircleOfScorn = 23,
    CleanShot = 2873,
    Combust = 3599,
    Cure = 120,
    Cure2 = 135,
    Cure3 = 131,
    Defiance = 48,
    Demolish = 29477,
    Diagnosis = 24284,
    Disembowel = 87,
    DivineVeil = 3540,
    DoomSpike = 86,
    Dosis = 24283,
    DragonfireDive = 96,
    Draw = 3590,
    Egeiro = 24287,
    EmpyrealArrow = 3558,
    EnergyDrain = 16508,
    EnergyDrainSCH = 167,
    EssentialDignity = 3614,
    Eukresia = 24290,
    FastBlade = 9,
    Feint = 7549,
    Fester = 181,
    FeyIllumination = 16538,
    FightOrFlight = 20,
    Fire = 141,
    Fire2 = 147,
    Fire3 = 152,
    FloodofDarkness = 16466,
    Freeze = 159,
    FullThrust = 84,
    GaussRound = 2874,
    Gemshine = 25883,
    GoringBlade = 3538,
    Gravity = 3615,
    Grit = 3629,
    Haima = 24305,
    HallowedGround = 30,
    HardSlash = 3617,
    HeatBlast = 7410,
    HeavySwing = 31,
    Helios = 3600,
    Holmgang = 43,
    Holy = 139,
    HotShot = 2872,
    Hypercharge = 17209,
    InnerBeast = 49,
    Interject = 7538,
    IronJaws = 3560,
    IronWill = 28,
    Jump = 92,
    Kardia = 24285,
    Ladonsbite = 106,
    LanceCharge = 85,
    LifeSurge = 83,
    Lightspeed = 3606,
    LucidDreaming = 7562,
    Lustrate = 189,
    MagesBallad = 114,
    Maim = 37,
    Malefic = 3596,
    Manaward = 157,
    Manafont = 158,
    Medica = 124,
    Medica2 = 133,
    Meditation = 3546,
    MythrilTempest = 16462,
    NaturesMinne = 7408,
    Outburst = 16511,
    Overpower = 41,
    Peloton = 7557,
    Phlegma = 24289,
    Physick = 16230,
    PhysickSCH = 190,
    Physis = 24288,
    PiercingTalon = 90,
    PitchPerfect = 7404,
    Play = 17055,
    PreciousBrilliance = 25884,
    PresenceofMind = 136,
    Prognosis = 24286,
    Prominence = 16457,
    RadiantAegis = 25799,
    RadiantFinale = 25785,
    RageOfHalone = 21,
    RagingStrikes = 101,
    RainOfDeath = 117,
    Raise = 125,
    Rampart = 7531,
    Reassemble = 2876,
    Redraw = 3593,
    RefulgentArrow = 98,
    Regen = 137,
    Reprisal = 7535,
    Rescue = 7571,
    Return = 6,
    Resurrection = 173,
    Ricochet = 2890,
    RiotBlade = 15,
    RookAutoturret = 2864,
    RookOverdrive = 7415,
    Ruin = 163,
    RuinSCH = 17869,
    RuinSCH2 = 17870,
    SacredSoil = 188,
    Scathe = 156,
    SecondWind = 7541,
    Sentinel = 17,
    Shadowbite = 16494,
    ShadowWall = 3636,
    Sheltron = 3542,
    ShieldBash = 16,
    ShieldLob = 24,
    Sidewinder = 3562,
    Sleep = 25880,
    SlugShot = 2868,
    SnapPunch = 56,
    Soteria = 24294,
    Souleater = 3632,
    SpineshatterDive = 95,
    SpinningEdge = 2240,
    SpiritsWithin = 29,
    SplitShot = 2866,
    SpreadShot = 2870,
    StalwartSoul = 16468,
    SteelCyclone = 51,
    SteelPeak = 3546,
    Stone = 119,
    Stormbite = 113,
    StormsPath = 42,
    SyphonStrike = 3623,
    Succor = 186,
    SummonCarbuncle = 25798,
    SummonEmerald = 25804,
    SummonEos = 17215,
    SummonRuby = 25802,
    SummonTopaz = 25803,
    SummonIfrit = 25805,
    Swiftcast = 7561,
    TheWanderersMinuet = 3559,
    ThrillofBattle = 40,
    Thunder = 144,
    Thunder2 = 7447,
    TotalEclipse = 7381,
    Tomahawk = 46,
    Toxicon = 24304,
    Transpose = 149,
    Troubadour = 7405,
    TrueNorth = 7546,
    TrueStrike = 54,
    TrueThrust = 75,
    TwinSnakes = 29476,
    Undraw = 9629,
    Unleash = 3621,
    Unmend = 3624,
    Vengeance = 44,
    VorpalThrust = 78,
    WhisperingDawn = 16537,
    Wildfire = 2878,
}
ac.avoid = {{ [902] = "front", [903] = "rear",[1022]="rear"}, { [902] = "rear", [903] = "rear", [1022]="rear"}}
ac.boss = {1677,1680}
ac.combo = {}
table.insert(ac.combo,ac.actions.FastBlade)
table.insert(ac.combo,ac.actions.RiotBlade)
table.insert(ac.combo,ac.actions.RageOfHalone)
table.insert(ac.combo,ac.actions.TotalEclipse)
table.insert(ac.combo,ac.actions.Prominence)
table.insert(ac.combo,ac.actions.TrueThrust)
table.insert(ac.combo,ac.actions.VorpalThrust)
table.insert(ac.combo,ac.actions.FullThrust)
table.insert(ac.combo,ac.actions.Disembowel)
table.insert(ac.combo,ac.actions.ChaosThrust)
table.insert(ac.combo,ac.actions.HeavySwing)
table.insert(ac.combo,ac.actions.Maim)
table.insert(ac.combo,ac.actions.StormsPath)
table.insert(ac.combo,ac.actions.Overpower)
table.insert(ac.combo,ac.actions.MythrilTempest)
table.insert(ac.combo,ac.actions.HardSlash)
table.insert(ac.combo,ac.actions.SyphonStrike)
table.insert(ac.combo,ac.actions.Souleater)
table.insert(ac.combo,ac.actions.Unleash)
table.insert(ac.combo,ac.actions.StalwartSoul)
table.insert(ac.combo,ac.actions.SplitShot)
table.insert(ac.combo,ac.actions.SlugShot)
table.insert(ac.combo,ac.actions.CleanShot)

ac.constants = {
    version = "Alpha 0.8.6",
    stuckdistance = .5,
}

ac.adungeon = {[15] = 19, [16] = 20, [17] = 21,}
ac.dungeon = {[15] = 19, [16] = 20, [17] = 21, [24] = 23, [28] = 24, [32] = 25, [41] = 27, [50] = 33, [53] = 34, [55] = 35, [57] = 36,}
ac.dgitemlevel = {[15] = 1, [16] = 1, [17] = 1, [24] = 1, [28] = 1, [32] = 1, [41] = 1, [50] = 90, [53] = 105, [55] = 110, [57] = 115,}
ac.entities = {deadfriends = nil, enemies = nil, friends = nil,}
ac.flags = {
    autotarget = true,
    avoiding = false,
    bosstarget = false,
    canaoe = false,
    canheal = true,
    caninterrupt = false,
    canpoll = false,
    canweave = false,
    damagedfriends = 0,
    enemiesinsidecone = 0,
    gcd = 0,
    hasinitdungeon = false,
    heading = 0,
    idletime = 0,
    ismoving = false,
    lastaction = 0,
    lastcombat = 0,
    lastinteract = 0,
    lastweave = 0,
    missionindex = 0,
    mode = "simple",
    movetime = 0,
    objective = "damage",
    outsidecombat = 0,
    pos = {},
    prevcombat = false,
    prevjob = 0,
    prevmapid = 0,
    prevmissionindex = 0,
    prevpos = {},
    queue = 0,
    repairwindow = false,
    sleep = 0,
    songlist = 1,
    stuck = false,
    stucktime = 0,
    teamdamage = 0,
    toughness = 0,
}
ac.gauge = {
    BLMumbraltimer = nil,
    BLMumbraltype = nil,
    SGEcharges = nil,
    SGEmeter = nil,
    SMNactivesummon = nil,
    SMNaetherflow = nil,
    SMNemerald = nil,
    SMNruby = nil,
    SMNtopaz = nil,
    SMNlockdown = nil,
    SMNsummontime = nil,
    SMNstacks = nil,
    MCHheat = nil,
    MCHbattery = nil,
    MCHoverheated = nil,
    DRKdarkside = nil,
    SCHaetherflow = nil,
}
ac.gcd = {
    [FFXIV.JOBS.ARCHER] = ac.actions.BurstShot,
    [FFXIV.JOBS.BARD] = ac.actions.BurstShot,
    [FFXIV.JOBS.LANCER] = ac.actions.TrueThrust,
    [FFXIV.JOBS.DRAGOON] = ac.actions.TrueThrust,
    [FFXIV.JOBS.GLADIATOR] = ac.actions.FastBlade,
    [FFXIV.JOBS.PALADIN] = ac.actions.FastBlade,
    [FFXIV.JOBS.ARCANIST] = ac.actions.Ruin,
    [FFXIV.JOBS.SUMMONER] = ac.actions.Ruin,
    [FFXIV.JOBS.THAUMATURGE] = ac.actions.Blizzard,
    [FFXIV.JOBS.BLACKMAGE] = ac.actions.Blizzard,
    [FFXIV.JOBS.MARAUDER] = ac.actions.HeavySwing,
    [FFXIV.JOBS.WARRIOR] = ac.actions.HeavySwing,
    [FFXIV.JOBS.PUGILIST] = ac.actions.Bootshine,
    [FFXIV.JOBS.MONK] = ac.actions.Bootshine,
    [FFXIV.JOBS.ROGUE] = ac.actions.SpinningEdge,
    [FFXIV.JOBS.NINJA] = ac.actions.SpinningEdge,
    [FFXIV.JOBS.MACHINIST] = ac.actions.SplitShot,
    [FFXIV.JOBS.DARKKNIGHT] = ac.actions.HardSlash,
    [FFXIV.JOBS.CONJURER] = ac.actions.Stone,
    [FFXIV.JOBS.WHITEMAGE] = ac.actions.Stone,
    [FFXIV.JOBS.ASTROLOGIAN] = ac.actions.Malefic,
    [FFXIV.JOBS.SCHOLAR] = ac.actions.RuinSCH,
}
ac.heals = {
    ac.actions.Cure,
    ac.actions.Cure2,
    ac.actions.Cure3,
    ac.actions.Medica,
    ac.actions.Medica2,
    ac.actions.Benefic,
    ac.actions.Benefic2,
    ac.actions.Helios,
    ac.actions.AspectedHelios,
    ac.actions.Physick,
    ac.actions.PhysickSCH,
    ac.actions.Adloquium,
    ac.actions.Succor,
}
ac.maps = {"Sastasha","The Tam-Tara Deepcroft","Copperbell Mines","The Thousand Maws of Toto-Rak","Haukke Manor","Brayflox's Longstop","Stone Vigil","The Keeper of the Lake","Sohm Al","The Aery","The Vault"}
ac.poll = {
    gcd = nil,
    weave = nil,
    consumables = nil,
}
ac.range = {
    aoe = 0,
    aoeheal = 0,
    basic = 0,
    buff = 0,
    cone = 0,
    heal = 0,
    jump = 0,
    jumpmin = 0,
    radiusRainOfDeath = 8,
    radiusShadowbite = 5,
    rangepadding = 2,
    short = 0,
}
local file = FileLoad(GetLuaModsPath().."EASECore\\settings.ini")
if (file) then
    ac.settings = file
else
    ac.settings = {
        aoethreshold = 3,
        aoeheal0 = 65,
        aoeheal1 = 100,
        aoeheal2 = 200,
        aoeheal3 = 325,
        aoeheal4 = 475,
        autocombat = false,
        autolevel = false,
        bosshpmultiplier = 8,
        dangerouscast = 2.5,
        debug = false,
        dotrefresh = 8,
        dotthreshold = 20,
        exclusive = true,
        hpthreshold0 = 90,
        hpthreshold1 = 75,
        hpthreshold2 = 50,
        hpthreshold3 = 33,
        hpcritical = 15,
        missionindex = 0,
        mphalf = 5000,
        mpcritical = 1000,
        pullmode = false,
        repair = { frequency = 3000000, last = Now()},
        repaired = true,
        trashhpmultiplier = 2,
        verbose = true,
    }
end
ac.style = {
    cyan = {a = 1,b = 1,g = 1,r = 0},
	default = {a = 0.44,b = 0.63,g = 0.5,r = 0.185},
	green = {a = 0.55,b = 0,g = 0.9,r = 0},
	orange = {a = 0.6,b = 0,g = 0.6,r = 1},
    red = {a = 0.7,b = .2,g = .2,r = 0.9,},
	yellow = {a = 1,b = 0,g = 1,r = 1},
}
ac.targets = {
    boss = nil,
    cone = {ents=0},
    heal = nil,
    manual = nil,
    manualheal = nil,
    manualrevive = nil,
    rangecircle = {ents=0},
    revive = nil,
    short = {},
    single = nil,
    tankpoke = nil,
}
ac.timer = {
    avoid = { timeout = 500, last = 0},
    breath = { frequency = 5000, last = 0},
    channeledDOT = { timeout = 3000, last = 0},
    energydrain = { timeout = 60000, last = 0},
    gcd = { last = 0},
    halfbeat = { frequency = 500, last = 0},
    heal = { timeout = 3000, last = 0},
    heartbeat = { frequency = 1000, last = 0},
    jump = { timeout = 2000, last = 0},
    peloton = { timeout = 1, last = 0},
    poll = { timeout = 200, last = 0},
    pulse = { frequency = 100, last = 0},
    sprint = { timeout = 1, last = 0},
    stuck = { timeout = 5, last = 0},
    weave = { timeout = 1400, frequency = 500, last = 0},
}
ac.todo = {}
function ac.AutoFollow()
    if ac.settings.autolevel then
        local target = nil
        local el = EntityList("alive,aggressive,maxdistance=30")
        for i, e in pairs(el) do
            if e.chartype == 9 then
                if ac.IsCaster() or ac.IsRange() then if ac.IsRange(e) or ac.IsCaster(e) then target = e end end
                if ac.IsHealer() then if ac.IsRange(e) or ac.IsCaster(e) then target = e end end
                if ac.IsTank() then if ac.IsMelee(e) then target = e end end
                if ac.IsMelee() then if ac.IsTank(e) then target = e end end
                if ac.IsMelee() then if ac.IsMelee(e) then target = e end end
            end
        end
        local boss = ac.targets.single or MGetTarget()
        if boss and table.valid(boss) and (ac.IsTank() or ac.IsMelee())then
            for i, e in pairs(ac.boss) do
                if e == boss.contentid then target = boss break end
            end
        end
        --if target then d("Job: "..tostring(target.job)) end
        if Player.Incombat and target and not ac.flags.avoiding then
            if ac.GetDistance(Player.pos,target.pos) > 2 then
                if ac.flags.stuck then
                    Player:MoveTo(target.pos.x,target.pos.y,target.pos.z)
                end
            end
            if ac.GetDistance(Player.pos,target.pos) > .4 then
                if target == boss then
                    local offset = 0 if ac.IsTank() then offset = .4 elseif ac.IsMelee() then offset = -.5 end
                    local pos = GetPosFromDistanceHeading(target.pos, offset, target.pos.h)
                    MoveDirectly3D(pos)
                else
                    MoveDirectly3D(target.pos)
                end
            elseif not MIsCasting() then
                Player:Stop()
            end
        end
    end
end
function ac.Avoidance()
    if ac.settings.autolevel and (ac.IsTank() or ac.IsMelee()) then
        if TimeSince(ac.timer.avoid.last) > ac.timer.avoid.timeout and not ac.flags.avoiding then
            local t = MGetTarget()
            if t and table.valid(t) then
                local av = nil
                if ac.IsTank() then av = ac.avoid[1][t.castinginfo.castingid] or ac.avoid[1][t.castinginfo.channelingid]
                elseif ac.IsMelee() then av = ac.avoid[2][t.castinginfo.castingid] or ac.avoid[2][t.castinginfo.channelingid] end
                if av then
                    if av == "front" then ac.MoveToFront(t) ac.flags.avoiding = true ac.timer.avoid.last = Now() return end
                    if av == "rear" then ac.MoveToRear(t) ac.flags.avoiding = true ac.timer.avoid.last = Now() return end
                end
            end
        end
        if TimeSince(ac.timer.avoid.last) > ac.timer.avoid.timeout then ac.flags.avoiding = false end
    end
end
function ac.CastChannel(target,action) local a = ActionList:Get(1,action)
    if a and ac.flags.canpoll and a.level <= Player.level and not Player:IsMoving() and a.range >= target.distance2d and not IsMounted() and not MIsCasting() then
        Player:SetFacing(target.pos.x,target.pos.y,target.pos.z)
        Player:SetTarget(target.id) a:Cast(target.id) if ac.settings.verbose then d("[EASECore] - Channeling: "..tostring(a.name)) end
        ac.poll.gcd = action
        ac.GetManualTarget()
    end
end
function ac.CastInstant(target,action) local a = ActionList:Get(1,action)
    if a and ac.flags.canpoll and ac.poll.gcd == nil and a.level <= Player.level and a.range >= target.distance2d and not IsMounted() then
        --Player:SetTarget(target.id)
        Player:SetFacing(target.pos.x,target.pos.y,target.pos.z)
        a:Cast(target.id) if ac.settings.verbose then d("[EASECore] - Polled: "..tostring(a.name)) end
        ac.poll.gcd = action
        ac.timer.poll.last = Now()
       ac.GetManualTarget()
    end
end
function ac.CastWeave(target,action) local a = ActionList:Get(1,action)
    if a and ac.flags.canweave and not ac.poll.weave and not a.isoncd and a.level <= Player.level and a.range >= target.distance2d and not IsMounted() then
        Player:SetFacing(target.pos.x,target.pos.y,target.pos.z)
        a:Cast(target.id) if ac.settings.verbose then d("[EASECore] - Weaving: "..tostring(a.name)) end
        ac.poll.weave = action
        ac.timer.weave.last = Now()
        ac.GetManualTarget()
    end
end
function ac.Color(r,g,b,a) return GUI:ColorConvertFloat4ToU32(r,g,b,a) end
function ac.CombatAstrologian()
    if ac.flags.mode == "simple" then
        local tz = ac.targets.revive or ac.IsValidReviveTarget()
        local tr = ac.IsValidAttackTarget() or ac.targets.rangecircle
        local ts = ac.IsValidAttackTarget() or ac.targets.single or ac.targets.boss
        local th = ac.IsValidHealTarget() or ac.targets.heal
        if tz and (ac.flags.canweave or not Player.Incombat)then
            if ac.HasBuff("Swiftcast") then ac.CastInstant(tz,ac.actions.Ascend) end
            ActionList:Get(1,ac.actions.Swiftcast):Cast()
        end
        if ac.flags.canweave then
            if th then
                if th.hp.percent < ac.settings.hpthreshold3 then ac.CastWeave(th,ac.actions.EssentialDignity) end
            end
            if ts then
                if ac.GetToughness(ts) > 10 then ac.CastWeave(Player,ac.actions.Lightspeed) end
            end
        end
        if ac.flags.canheal and ac.IsAOEHealGood() and ac.flags.teamdamage > ac.settings.aoeheal0 and not ac.HasBuff("Aspected Helios") then ac.CastChannel(Player,ac.actions.AspectedHelios) end
        if ac.flags.canheal and ac.IsAOEHealGood() and ac.flags.teamdamage > ac.settings.aoeheal0 then ac.CastChannel(Player,ac.actions.Helios) end
        if th then
            if th.hp.percent < ac.settings.hpthreshold1 and Player:IsMoving() and not ac.HasBuff("Aspected Benefic", th) then ac.CastInstant(th,ac.actions.AspectedBenefic) end
            if ac.flags.canheal and th.hp.percent < ac.settings.hpthreshold2 then ac.CastChannel(th,ac.actions.Benefic2) end
            if ac.flags.canheal and th.hp.percent < ac.settings.hpthreshold2 then ac.CastChannel(th,ac.actions.Benefic) end
        end
        if tr and ac.IsAOECandidate(tr) then
            ac.CastChannel(tr,ac.actions.Gravity)
        end
        if ts then
            if Player:IsMoving() or not ac.HasDOT(ts,1) then ac.CastInstant(ts,ac.actions.Combust) end
            ac.CastChannel(ts,ac.actions.Malefic)
        end
    end
end
function ac.CombatBard()
    if ac.flags.mode == "simple" then
        -- AOE
        local tr = ac.targets.rangecircle
        if (ac.HasBuff("Shadowbite Ready") and ac.IsAOECandidate(tr)) then ac.CastInstant(tr,ac.actions.Shadowbite) end
        local tc = ac.targets.cone
        if (ac.IsAOECandidate(tc)) then ac.CastInstant(tc,ac.actions.Ladonsbite) end
        local ts = ac.IsValidAttackTarget() or ac.targets.single or ac.targets.boss
        local th = ac.IsValidHealTarget() or ac.targets.heal
        if ts and not ts.los2 then Player:SetTarget(ts) end
        -- WEAVING
        if (ac.flags.canweave) then
            if (ac.flags.teamdamage > ac.settings.aoeheal1 and ac.IsAOEHealGood()) then ac.CastWeave(Player,ac.actions.Troubadour) end
            if (ac.flags.teamdamage > ac.settings.aoeheal2 and ac.IsAOEHealGood()) then ac.CastWeave(Player,ac.actions.NaturesMinne) end
            if (ts and not ac.HasBuff("Barrage")) then
                if (Player.gauge[1] > 100) then ac.CastWeave(Player,ac.actions.RadiantFinale) end
                if (ac.flags.songlist == 1 and Player.gauge[3] <= 3000) or (not ac.UpdateSongs() and ActionList:Get(1,ac.actions.ArmysPaeon).isoncd) then ac.CastWeave(ts,ac.actions.TheWanderersMinuet) end
                if (ac.HasBuff("The Wanderer's Minuet") and Player.gauge[2] == 0 and Player.gauge[3] <= 4000) or (not ac.UpdateSongs() and ActionList:Get(1,ac.actions.TheWanderersMinuet).isoncd) then ac.CastWeave(ts,ac.actions.MagesBallad) end
                if (ac.flags.songlist == 3 and Player.gauge[3] <= 12000) or (not ac.UpdateSongs() and ActionList:Get(1,ac.actions.MagesBallad).isoncd) then ac.CastWeave(ts,ac.actions.ArmysPaeon) end
            end
            if (ts) then
                ac.CastWeave(Player,ac.actions.BattleVoice)
                if (((Player.gauge[2] == 3 or Player.gauge[3] < 1000) and ac.HasBuff("The Wanderer's Minuet")) ) then ac.CastWeave(ts, ac.actions.PitchPerfect) end
                ac.CastWeave(Player,ac.actions.RagingStrikes)
                if (not ac.HasBuff("Barrage")) then ac.CastWeave(ts,ac.actions.EmpyrealArrow) end
                if (not ac.HasBuff("Straight Shot Ready")) then ac.CastWeave(Player,ac.actions.Barrage) end
                ac.CastWeave(ts,ac.actions.Sidewinder)
            end
            if (tr) then
                local r = ac.IsValidAttackTarget() or ac.targets.rangecircle
                if (ac.IsAOECandidate(r)) then
                    ac.CastWeave(r,ac.actions.RainOfDeath)
                elseif(not ac.HasBuff("Barrage")) then
                    ac.CastWeave(r,ac.actions.Bloodletter)
                end
            end
        end
        -- SINGLE
        if (ts) then
            if (ac.IsDOTexpiring(ts,1) or ac.IsDOTexpiring(ts,2) and not ac.HasBuff("Barrage")) then ac.CastInstant(ts,ac.actions.IronJaws) end -- needs higher prio to refresh dot properly
            if ac.HasBuff("Blast Arrow Ready") then ac.CastInstant(ts,ac.actions.BlastArrow) end
            if (Player.gauge[4] > 80) then ac.CastInstant(ts,ac.actions.ApexArrow) end
            if (ac.HasBuff("Straight Shot Ready")) then ac.CastInstant(ts,ac.actions.RefulgentArrow) end
            if (not ac.HasDOT(ts,1)) then ac.CastInstant(ts,ac.actions.CausticBite)
            elseif (not ac.HasDOT(ts,2)) then ac.CastInstant(ts,ac.actions.Stormbite)
            else ac.CastInstant(ts,ac.actions.BurstShot) end
            ac.CastInstant(ts,ac.actions.BurstShot)
        end
    end
end
function ac.CombatBlackMage()
    if ac.flags.mode == "simple" then
        local tr = ac.IsValidAttackTarget() or ac.targets.rangecircle
        local ts = ac.IsValidAttackTarget() or ac.targets.single or ac.targets.boss
        local th = ac.IsValidHealTarget() or ac.targets.heal
        local tp = ActionList:Get(1,ac.actions.Transpose)
        local sc = ActionList:Get(1,ac.actions.Swiftcast)

        
        if not Player.Incombat and ac.gauge.BLMumbraltimer < 2000 and ac.gauge.BLMumbraltype ~= 0 then ac.CastInstant(Player,ac.actions.Transpose) end
        if ac.flags.canweave and Player.hp.percent < ac.settings.hpthreshold3 then ac.CastWeave(Player,ac.actions.Manaward) end
        if (Player.mp.current < 1600 or ac.gauge.BLMumbraltimer < 2000) and ac.gauge.BLMumbraltype ~= 0 and ac.flags.canweave then
            ac.CastWeave(Player,ac.actions.Transpose)
        end
        if tr then
            if not ac.IsSwiftcasted() and ac.HasBuff("Thundercloud") or not ac.IsSwiftcasted() and (Player.castinginfo.lastcastid ~= ac.actions.Thunder2 and ac.IsAOECandidate(tr) and not ac.HasDOT(tr,1) and not ac.HasDOT(tr,2)) then ac.CastChannel(tr,ac.actions.Thunder2) ac.timer.channeledDOT.last = Now() end
            if ac.IsAOECandidate(tr) and ac.gauge.BLMumbraltype == -3 and Player.mp.current > 3000 then ac.CastChannel(tr,ac.actions.Fire2) end
            if ac.IsAOECandidate(tr) and ac.gauge.BLMumbraltype == 3 then ac.CastChannel(tr,ac.actions.Blizzard2) end
            if ac.IsAOECandidate(tr) and ac.gauge.BLMumbraltype < 0 then ac.CastChannel(tr,ac.actions.Freeze) end
        end

        if ts then
            if (ac.gauge.BLMumbraltype <= 1 and ac.gauge.BLMumbraltype >= -1) and not ac.IsBLMYoking() and not sc.isoncd then sc:Cast() end
            if ac.gauge.BLMumbraltype == -3 and ac.HasBuff("Firestarter") then ac.CastInstant(ts,ac.actions.Fire3) end
            if not ac.IsSwiftcasted() and Player:IsMoving() then ac.CastInstant(ts,ac.actions.Scathe) end
            if not ac.IsSwiftcasted() and ac.HasBuff("Thundercloud") or not ac.IsSwiftcasted() and (Player.castinginfo.lastcastid ~= ac.actions.Thunder and not ac.HasDOT(ts,1) and not ac.HasDOT(ts,2)) then ac.CastChannel(ts,ac.actions.Thunder) ac.timer.channeledDOT.last = Now() end
            if ac.gauge.BLMumbraltype == -3 or (ac.gauge.BLMumbraltype == 1 and Player.mp.current >= 4000) then ac.CastChannel(ts,ac.actions.Fire3) end
            if ac.gauge.BLMumbraltype == 3 or (ac.gauge.BLMumbraltype <= 1 and Player.mp.current >= 800)then ac.CastChannel(ts,ac.actions.Blizzard3) end
            if Player.mp.current >= 1600 and ac.gauge.BLMumbraltype >= 0 then ac.CastChannel(ts,ac.actions.Fire) else
                if ac.flags.canweave and ac.gauge.BLMumbraltype == -1 then ac.CastWeave(Player,ac.actions.Transpose) end
            end
            if not ac.IsSwiftcasted() and not ac.IsBLMYoked() and not ac.IsBLMYoking() and Player.mp.current < 3000 and tp.cd == 0 then
                tp:Cast()
            end
            if ac.gauge.BLMumbraltype == -1 and Player.mp.current < 3000 and tp.isoncd then
                ac.CastChannel(ts,ac.actions.Blizzard)
            elseif not ac.IsSwiftcasted() and not ac.IsBLMYoked() and not ac.IsBLMYoking() and Player.mp.current > 3000 and tp.cd == 0 then
                tp:Cast()
            end
        end
        if tp.cd == 0 and ac.gauge.BLMumbraltimer < 1000 and ac.gauge.BLMumbraltype ~= 0 then tp:Cast() end
    end
end
function ac.CombatDarkKnight()
    if ac.flags.mode == "simple" then
        if(Duty:GetQueueStatus() == 4) then --inside dungeon
            if(not ac.HasBuff("Grit") and not ac.IsInBossDungeon()) then
                ActionList:Get(1, ac.actions.Grit):Cast()
            end
        end
        -- Start Poking things when already in combat or have a tasty look on an innocent mob else stay put
        local tp = ac.targets.tankpoke
        local ts = ac.IsValidAttackTarget() or ac.targets.single or ac.targets.boss
        local tc = ac.targets.cone or ts
        if Player.Incombat then
            if tc and (ac.gauge.DRKdarkside < 30000 or Player.mp.current > 9000) then ac.CastWeave(tc,ac.actions.FloodofDarkness) end
            if tp then ac.CastInstant(tp,ac.actions.Unmend) end
        else
            local tp = ac.IsValidAttackTarget()
            if tp and tp.distance2d > ac.range.basic and tp.distance2d < ac.range.long then ac.CastInstant(tp,ac.actions.Unmend) end
        end
        if ac.flags.canweave then
            -- [MITIGATION]
            
            if ts and ts.hp.max > Player.hp.max * ac.settings.bosshpmultiplier or ac.IsAOEGood(ac.range.short) then --check if target is a boss, not sure with the algorithm
                ac.flags.bosstarget = true
                 if Player.hp.percent < ac.settings.hpthreshold3 and not ac.HasBuff("Rampart") then ac.CastWeave(Player,ac.actions.ShadowWall) end
                -- if Player.hp.percent < ac.settings.hpthreshold3 and not ac.HasBuff("Rampart") and not ac.HasBuff("Sentinel") then ac.CastWeave(Player,ac.actions.Bulwark) end
                -- if Player.hp.percent < ac.settings.hpcritical then ac.CastWeave(Player,ac.actions.HallowedGround) end
            else
                ac.flags.bosstarget = false
            end
        end
        -- AOE TIME
        if ac.IsAOEGood(ac.range.short) then
            if ac.IsCombo(ac.actions.Unleash) then ac.CastInstant(Player,ac.actions.StalwartSoul) end
            if not ac.IsCombo(ac.actions.Unleash) then ac.CastInstant(Player,ac.actions.Unleash) end
        else    -- Less than AOE threshold
            -- Dunno what logic to add...yet
        end
        --table.sort(ac.entities.enemies, function(l,r)	return math.distance3d(Player.pos,l.pos) < math.distance3d(Player.pos,r.pos) end)
        table.sort(ac.targets.short, function(l,r) return (l.hp.current) < (r.hp.current) end)
        table.sort(ac.targets.short, function(l,r) return (l.aggropercentage) < (r.aggropercentage) end)
        -- [SINGLE TARGET ROTATION]
        if table.valid(ac.targets.short) then
            local ts = ac.IsValidAttackTarget() or ac.targets.short[1]
            if ac.IsCombo(ac.actions.SyphonStrike) then ac.CastInstant(ts,ac.actions.Souleater) end
            if ac.IsCombo(ac.actions.HardSlash) then ac.CastInstant(ts,ac.actions.SyphonStrike) end
            if not ac.IsCombo(ac.actions.HardSlash) then ac.CastInstant(ts,ac.actions.HardSlash) end
        end
    end
end
function ac.CombatDragoon()
    if ac.flags.mode == "simple" then
        local tc = ac.targets.cone
        if (ac.IsAOECandidate(tc)) and ac.HasBuff("Power Surge") then ac.CastInstant(tc,ac.actions.DoomSpike) end
        local tr = ac.IsValidAttackTarget() or ac.targets.rangecircle
        local ts = ac.IsValidAttackTarget() or ac.targets.single or ac.targets.boss
        if ac.flags.canweave and Player.Incombat then
            ac.CastWeave(Player,ac.actions.BattleLitany)
            if ac.IsCombo(ac.actions.Disembowel) then ac.CastWeave(Player,ac.actions.TrueNorth) end -- TO Abstract and make check on UpdatePositionals
            if Player.level < 26 and ac.IsCombo(ac.actions.TrueThrust) then ac.CastWeave(Player,ac.actions.LifeSurge) end
            if ac.IsCombo(ac.actions.VorpalThrust) and Player.level >= 26 and ac.HasBuff("Power Surge") then ac.CastWeave(Player,ac.actions.LifeSurge) end
            if tr then ac.CastWeave(tr,ac.actions.Jump) end
            if ts then ac.CastWeave(Player,ac.actions.LanceCharge) end
        end
        if ts then
            if not ts.los2 then
                Player:SetTarget(ts)
            else
                if ac.IsCombo(ac.actions.Disembowel) then ac.CastInstant(ts,ac.actions.ChaosThrust) end
                if ac.IsCombo(ac.actions.TrueThrust) and not ac.HasBuff("Power Surge") then ac.CastInstant(ts,ac.actions.Disembowel) end 
                if ac.IsCombo(ac.actions.VorpalThrust) then ac.CastInstant(ts,ac.actions.FullThrust) end
                if ac.IsCombo(ac.actions.TrueThrust) then ac.CastInstant(ts,ac.actions.VorpalThrust) end
                if not ac.IsCombo(ac.actions.TrueThrust) then ac.CastInstant(ts,ac.actions.TrueThrust) end
            end
        end
        if tr then
            if TimeSince(ac.timer.jump.last) > ac.timer.jump.timeout then
                if ((ac.IsAOECandidate(tr) and tr.distance2d > ac.range.jumpmin) or ac.settings.autolevel and ac.IsInDungeon()) and Player.hp.percent > ac.settings.hpthreshold1 then ac.CastWeave(tr,ac.actions.DragonfireDive) end
                if (tr.distance2d > ac.range.jumpmin or ac.settings.autolevel and ac.IsInDungeon()) and Player.hp.percent > ac.settings.hpthreshold1 then ac.CastWeave(tr,ac.actions.SpineshatterDive) end
                if not ac.HasBuff("Life Surge") and tr.distance2d > ac.range.basic+2 and not (ac.flags.lastaction == ac.actions.SpineshatterDive or ac.flags.lastaction == ac.actions.DragonfireDive) then ac.CastInstant(tr,ac.actions.PiercingTalon) end
            end
        end
    end
end
function ac.CombatMachinist()
    if ac.flags.mode == "simple" then
        local tr = ac.IsValidAttackTarget() or ac.targets.rangecircle
        local tc = ac.IsValidAttackTarget() or ac.targets.cone
        local ts = ac.IsValidAttackTarget() or ac.targets.single
        local th = ac.IsValidHealTarget() or ac.targets.heal
        if tc and ac.IsAOECandidate(tc) then ac.CastInstant(tc,ac.actions.SpreadShot) end
        if ac.flags.canweave then
            if ac.gauge.MCHbattery > 80 then ac.CastWeave(Player,ac.actions.RookAutoturret) end
            if tr and ac.IsAOECandidate(tr) then ac.CastWeave(tr,ac.actions.Ricochet) end
            if ac.gauge.MCHheat > 50 and not ac.HasBuff("Overheated") and not tc and not ac.IsAOECandidate(tc) then
                ac.CastWeave(Player,ac.actions.Hypercharge)
            end

            if ac.IsCombo(ac.actions.SlugShot) then ac.CastWeave(Player,ac.actions.Reassemble) end
            if ts then
                if not ac.HasBuff("Reassembled") then ac.CastWeave(ts,ac.actions.GaussRound) end
                if ac.GetToughness(ts) > 5 then ac.CastWeave(ts,ac.actions.Wildfire) end
            end
        end


        if ts then
            --local hb = ActionList:Get(1,ac.actions.HeatBlast)
            if not ac.HasBuff("Reassembled") and ac.HasBuff("Overheated") then ac.CastInstant(ts,ac.actions.HeatBlast) end
            if not ac.HasBuff("Reassembled") and ActionList:Get(1,ac.actions.HotShot).cd == 0 then ac.CastInstant(ts,ac.actions.HotShot) end
            if ac.IsCombo(ac.actions.SlugShot) then ac.CastInstant(ts,ac.actions.CleanShot) end
            if ac.IsCombo(ac.actions.SplitShot) then ac.CastInstant(ts,ac.actions.SlugShot) end
            if not ac.IsCombo(ac.actions.SplitShot) then ac.CastInstant(ts,ac.actions.SplitShot) end
        end
    end
end

function ac.CombatPaladin()
    if(ac.flags.mode == "simple") then
        if(Duty:GetQueueStatus() == 4) then --inside dungeon
            if(not ac.HasBuff("Iron Will") and not ac.IsInBossDungeon()) then
                ActionList:Get(1, ac.actions.IronWill):Cast()
            end
        end
        -- Start Poking things when already in combat or have a tasty look on an innocent mob else stay put
        local tp = ac.targets.tankpoke
        local th = ac.IsValidHealTarget() or ac.targets.heal
        if Player.Incombat then
            if tp then ac.CastInstant(tp,ac.actions.ShieldLob) end
        else
            local tp = ac.IsValidAttackTarget()
            if tp and tp.distance2d > ac.range.basic and tp.distance2d < ac.range.long then ac.CastInstant(tp,ac.actions.ShieldLob) end
        end
        local ts = ac.IsValidAttackTarget() or ac.targets.single
        if ac.flags.canweave then
            -- [MITIGATION]
            if ac.flags.teamdamage >= ac.settings.aoeheal1 then ac.CastWeave(Player,ac.actions.DivineVeil) end
            if table.valid(Player.gauge) then
                if Player.gauge[1] > ac.settings.hpthreshold1 and Player.hp.percent < ac.settings.hpthreshold0 then
                    ac.CastWeave(Player,ac.actions.Sheltron)
                elseif Player.gauge[1] > ac.settings.hpthreshold2 and Player.hp.percent < ac.settings.hpthreshold1 then
                    ac.CastWeave(Player,ac.actions.Sheltron)
                end
            end
            if ts and ts.hp.max > Player.hp.max * ac.settings.bosshpmultiplier or ac.IsAOEGood(ac.range.short) then --check if target is a boss, not sure with the algorithm
                ac.flags.bosstarget = true
                if Player.hp.percent < ac.settings.hpthreshold3 and not ac.HasBuff("Rampart") then ac.CastWeave(Player,ac.actions.Sentinel) end
                if Player.hp.percent < ac.settings.hpthreshold3 and not ac.HasBuff("Rampart") and not ac.HasBuff("Sentinel") then ac.CastWeave(Player,ac.actions.Bulwark) end
                if Player.hp.percent < ac.settings.hpcritical then ac.CastWeave(Player,ac.actions.HallowedGround) end
            else
                ac.flags.bosstarget = false
            end
        end
        -- AOE TIME
        if ac.IsAOEGood(ac.range.short) then
            if ac.flags.canweave then ac.CastWeave(Player,ac.actions.FightOrFlight) end
            if ac.flags.canweave then ac.CastWeave(Player,ac.actions.CircleOfScorn) end
            if (ac.flags.lastaction == ac.actions.TotalEclipse) then ac.CastInstant(Player,ac.actions.Prominence) end
            ac.CastInstant(Player,ac.actions.TotalEclipse)
        else    -- Less than AOE threshold
            -- Dunno what logic to add...yet
        end
        --table.sort(ac.entities.enemies, function(l,r)	return math.distance3d(Player.pos,l.pos) < math.distance3d(Player.pos,r.pos) end)
        table.sort(ac.targets.short, function(l,r) return (l.hp.current) < (r.hp.current) end)
        table.sort(ac.targets.short, function(l,r) return (l.aggropercentage) < (r.aggropercentage) end)
        -- [SINGLE TARGET ROTATION]
        if table.valid(ac.targets.short) then
            local ts = ac.IsValidAttackTarget() or ac.targets.short[1]
            if ac.HasBuff("Fight or Flight") and ActionList:Get(1,ac.actions.GoringBlade).cd == 0 then ac.CastInstant(ts,ac.actions.GoringBlade) end
            if ac.flags.canweave and ac.flags.bosstarget then ac.CastWeave(Player,ac.actions.FightOrFlight) end
            if ac.flags.canweave and ac.flags.bosstarget then ac.CastWeave(Player,ac.actions.CircleOfScorn) end
            if ac.flags.canweave then ac.CastWeave(ts,ac.actions.SpiritsWithin) end
            if ts.castinginfo.castinginterruptible and ac.flags.toughness > ac.settings.bosshpmultiplier / 2 then
                ac.flags.caninterrupt = true    -- Dont remove these flags, they're used for debugging purposes
                ac.CastInstant(ts,ac.actions.ShieldBash)
            else
                ac.flags.caninterrupt = false
            end
            if ac.IsCombo(ac.actions.RiotBlade) then ac.CastInstant(ts,ac.actions.RageOfHalone) end
            if ac.IsCombo(ac.actions.FastBlade) then ac.CastInstant(ts,ac.actions.RiotBlade) end
            if not ac.IsCombo(ac.actions.FastBlade) then ac.CastInstant(ts,ac.actions.FastBlade) end
        end
        if not tp and ts then ac.CastInstant(ts,ac.actions.ShieldLob) end
    end
end
function ac.CombatSage()
    if ac.flags.mode == "simple" then
        local ts = ac.IsValidAttackTarget() or ac.targets.single
        local th = ac.IsValidHealTarget() or ac.targets.heal
        local tz = ac.IsValidReviveTarget() or ac.targets.revive

        -- AOE HEALS
        if ac.flags.damagedfriends >= #ac.entities.friends/2 then
            if ac.flags.teamdamage >= ac.settings.aoeheal1/2 then ac.CastChannel(Player,ac.actions.Prognosis) end
        end
        
        -- WEAVING
        if ac.flags.canweave then
            if not ac.HasBuff("Eukresia") and ts and not ac.HasBuff("Eukrasian Dosis",ts) then ac.CastInstant(Player,ac.actions.Eukresia) end
            if ac.flags.teamdamage >= ac.settings.aoeheal1/3 then ac.CastInstant(Player,ac.actions.Physis) end
            if not ac.HasBuff("Kardion", th) and Player.Incombat then ac.CastInstant(th,ac.actions.Kardia) end
        end
        if th then
            if (th.hp.percent <= ac.settings.hpthreshold1) then ac.CastInstant(th,ac.actions.Diagnosis) end
        end
        if ts then 
            if ac.HasBuff("Eukrasia") then ac.Cast(ts,ac.actions.Dosis) end
            if ac.HasBuff("Eukrasian Dosis",ts) then ac.CastChannel(ts,ac.actions.Dosis) end
        end
    end
end
function ac.CombatScholar()
    if ac.flags.mode == "simple" then
        local tz = ac.IsValidReviveTarget() or ac.targets.revive
        local tr = ac.IsValidAttackTarget() or ac.targets.rangecircle
        local ts = ac.IsValidAttackTarget() or ac.targets.single or ac.targets.boss
        local th = ac.IsValidHealTarget() or ac.targets.heal
        if tz and (ac.flags.canweave or not Player.Incombat)then
            if ac.HasBuff("Swiftcast") then ac.CastInstant(tz,ac.actions.Resurrection) end
            ActionList:Get(1,ac.actions.Swiftcast):Cast()
        end
        if ac.flags.canweave then
            if ac.IsAOEHealGood() and ac.flags.teamdamage > ac.settings.aoeheal3 then ac.CastWeave(Player,ac.actions.FeyIllumination) end
            if ac.IsAOEHealGood() and ac.flags.teamdamage > ac.settings.aoeheal1 then ac.CastWeave(Player,ac.actions.WhisperingDawn) end
            if th and ac.HasBuff("Aetherflow") then local pos = th.pos ActionList:Get(1,ac.actions.SacredSoil):Cast(pos.x,pos.y,pos.z) end
        end
        if ac.flags.canheal and ac.IsAOEHealGood() and ac.flags.teamdamage > ac.settings.aoeheal1 and not ac.HasBuff("Galvanize") then ac.CastChannel(Player,ac.actions.Succor) end
        if th then
            --if th.hp.percent < ac.settings.hpthreshold1 and Player:IsMoving() and not ac.HasBuff("Regen", th) then ac.CastInstant(th,ac.actions.Regen) end
            if ac.flags.canweave and ac.HasBuff("Aetherflow") then
                if th.hp.percent < ac.settings.hpthreshold3 then ac.CastWeave(th,ac.actions.Lustrate) end
            end
            if ac.flags.canheal and th.hp.percent < ac.settings.hpthreshold2 and not ac.HasBuff("Galvanize", th) then ac.CastChannel(th,ac.actions.Adloquium) end
            if ac.flags.canheal and th.hp.percent < ac.settings.hpthreshold2 then ac.CastChannel(th,ac.actions.PhysickSCH) end
        end
        if ac.IsAOEGood(5) then ac.CastInstant(Player,ac.actions.ArtofWar) end
        if ts then
            if ac.flags.canweave then
                ac.CastWeave(Player,ac.actions.Aetherflow)
                if TimeSince(ac.timer.energydrain.last) > ac.timer.energydrain.timeout and ac.HasBuff("Aetherflow") then ac.CastWeave(ts,ac.actions.EnergyDrainSCH) ac.timer.energydrain.last = Now() end
            end
            if not ac.HasDOT(ts,1) then ac.CastInstant(ts,ac.actions.Bio) end
            if Player:IsMoving() then ac.CastInstant(ts,ac.actions.RuinSCH2) end
            ac.CastChannel(ts,ac.actions.RuinSCH)
        end
    end
end
function ac.CombatSummoner()
    if ac.flags.mode == "simple" then
        local tz = ac.IsValidReviveTarget() or ac.targets.revive
        local tr = ac.IsValidAttackTarget() or ac.targets.rangecircle
        local ts = ac.IsValidAttackTarget() or ac.targets.single or ac.targets.boss
        local th = ac.IsValidHealTarget() or ac.targets.heal
        
        if ac.flags.canweave then
            
            if Player.hp.percent < ac.settings.hpthreshold1 or ac.flags.teamdamage > ac.settings.aoeheal1 then ac.CastInstant(Player,ac.actions.RadiantAegis) end
            
            if ts then
                if ac.gauge.SMNaetherflow == 0 then ac.CastWeave(ts,ac.actions.EnergyDrain) end
                if ac.gauge.SMNaetherflow > 0 then ac.CastWeave(ts,ac.actions.Fester) end
            end
        end
        if tr then
            local r = ac.IsValidAttackTarget() or tr
            if ac.IsAOECandidate(r) then
                if ac.gauge.SMNactivesummon > 0 and r then ac.CastChannel(r,ac.actions.PreciousBrilliance) end
                ac.CastChannel(r,ac.actions.Outburst)
            end
        end
        if Player.Incombat then
            if ac.gauge.SMNruby == 0 and ac.gauge.SMNtopaz == 0 and ac.gauge.SMNemerald == 0 then ac.CastInstant(Player,ac.actions.Aethercharge) end
            if tr then if ac.HasBuff("Swiftcast") and ac.IsAOECandidate(tr) and ac.gauge.SMNactivesummon == 1 then ac.CastInstant(tr,ac.actions.PreciousBrilliance) end end
            if ts then
                if ac.HasBuff("Swiftcast") and ac.gauge.SMNactivesummon == 1 then ac.CastInstant(ts,ac.actions.Gemshine) end
                if ac.gauge.SMNactivesummon == 1 and not tz then ac.CastWeave(Player,ac.actions.Swiftcast) end
                if ac.gauge.SMNemerald == 1 and ac.gauge.SMNactivesummon == 0 then ac.CastInstant(ts,ac.actions.SummonEmerald) end
                if ac.gauge.SMNtopaz == 1 and ac.gauge.SMNactivesummon == 0 then ac.CastInstant(ts,ac.actions.SummonTopaz) end
                if ac.gauge.SMNruby == 1 and ac.gauge.SMNactivesummon == 0 then ac.CastInstant(ts,ac.actions.SummonIfrit) ac.CastInstant(ts,ac.actions.SummonRuby) end
            end
        end
        if th and th.hp.percent < ac.settings.hpthreshold2 then
            ac.CastChannel(th,ac.actions.Physick)
        end
        if ts then
            if ac.gauge.SMNactivesummon > 0 and ts then ac.CastChannel(ts,ac.actions.Gemshine) else
            ac.CastChannel(ts,ac.actions.Ruin) end
        end
    end
end
function ac.CombatWarrior()
    if ac.flags.mode == "simple" then
        if(Duty:GetQueueStatus() == 4) then --inside dungeon
            if(not ac.HasBuff("Defiance") and not ac.IsInBossDungeon()) then
                ActionList:Get(1, ac.actions.Defiance):Cast()
            end
        end
        local tp = ac.IsValidAttackTarget() or ac.targets.tankpoke
        local ts = ac.IsValidAttackTarget() or ac.targets.single
        local th = ac.IsValidHealTarget() or ac.targets.heal
        local tl = ac.targets.long
        if ac.flags.canweave then
            -- MITS
            if Player.hp.percent < ac.settings.hpcritical then ac.CastWeave(ts,ac.actions.Holmgang) end
            if Player.hp.percent < ac.settings.hpthreshold3 and not ac.HasBuff("Rampart") then ac.CastWeave(Player,ac.actions.Vengeance) end
            if Player.hp.percent < ac.settings.hpthreshold3 then ac.CastWeave(Player,ac.actions.ThrillofBattle) end
            ac.CastWeave(Player,ac.actions.Berserk)
        end
        if Player.Incombat then
            if ac.IsAOEGood(ac.range.short) and ac.gauge.WARbeast > 50 then ac.CastInstant(Player,ac.actions.SteelCyclone) end
            if ac.IsAOEGood(ac.range.short) and ac.IsCombo(ac.actions.Overpower) then ac.CastInstant(Player,ac.actions.MythrilTempest) end
            if ac.IsAOEGood(ac.range.short) and not ac.IsCombo(ac.actions.Overpower) then ac.CastInstant(Player,ac.actions.Overpower) end
        else
            local tp = ac.IsValidAttackTarget() or ac.targets.tankpoke
            if tp and tp.distance2d > ac.range.basic and tp.distance2d < ac.range.long and ac.IsInDungeon() and Player.hp.percent < ac.settings.hpthreshold2 then ac.CastInstant(tp,ac.actions.Tomahawk) end
        end
        table.sort(ac.targets.short, function(l,r) return (l.hp.current) < (r.hp.current) end)
        table.sort(ac.targets.short, function(l,r) return (l.aggropercentage) < (r.aggropercentage) end)
        -- [SINGLE TARGET ROTATION]
        if table.valid(ac.targets.short) then
            local ts = ac.IsValidAttackTarget() or ac.targets.short[1]
            if ac.gauge.WARbeast > 50 then ac.CastInstant(ts,ac.actions.InnerBeast) end
            if ac.IsCombo(ac.actions.Maim) then ac.CastInstant(ts,ac.actions.StormsPath) end
            if ac.IsCombo(ac.actions.HeavySwing) then ac.CastInstant(ts,ac.actions.Maim) end
            if not ac.IsCombo(ac.actions.HeavySwing) then ac.CastInstant(ts,ac.actions.HeavySwing) end
        end
        if Player.Incombat and tp and tp.distance2d > ac.range.basic then ac.CastInstant(tp,ac.actions.Tomahawk) end
        if Player.Incombat and tl and tl.distance2d > ac.range.basic then ac.CastInstant(tl,ac.actions.Tomahawk) end

        --if tl then ac.CastInstant(tl,ac.actions.Tomahawk) end
    end
end
function ac.CombatWhiteMage() --Whole section needs overhaul, I still can't find the time
    if ac.flags.mode == "simple" then
        local tz = ac.IsValidReviveTarget() or ac.targets.revive
        local tr = ac.IsValidAttackTarget() or ac.targets.rangecircle
        local ts = ac.IsValidAttackTarget() or ac.targets.single or ac.targets.boss
        local th = ac.IsValidHealTarget() or ac.targets.heal
        
        if tz and (ac.flags.canweave or not Player.Incombat)then
            if ac.HasBuff("Swiftcast") then ac.CastInstant(tz,ac.actions.Raise) end
            ActionList:Get(1,ac.actions.Swiftcast):Cast()
        end
        if ac.flags.canweave then
            if th then
                if th.hp.percent < ac.settings.hpcritical then ac.CastWeave(th,ac.actions.Benediction) end
            end
            if ts then
                if ac.GetToughness(ts) > 10 then ac.CastWeave(Player,ac.actions.PresenceofMind) end
            end
        end
        if ac.flags.canheal and ac.IsAOEHealGood() and ac.flags.teamdamage > ac.settings.aoeheal2 then ac.CastChannel(Player,ac.actions.Cure3) end
        if ac.flags.canheal and ac.IsAOEHealGood() and ac.flags.teamdamage > ac.settings.aoeheal0 and not ac.HasBuff("Medica II") then ac.CastChannel(Player,ac.actions.Medica) end
        if ac.flags.canheal and ac.IsAOEHealGood() and ac.flags.teamdamage > ac.settings.aoeheal0 then ac.CastChannel(Player,ac.actions.Medica) end
        if th then
            if th.hp.percent < ac.settings.hpthreshold1 and Player:IsMoving() and not ac.HasBuff("Regen", th) then ac.CastInstant(th,ac.actions.Regen) end
            if ac.flags.canheal and th.hp.percent < ac.settings.hpthreshold2 then ac.CastChannel(th,ac.actions.Cure2) end
            --if th.hp.percent < ac.settings.hpthreshold1 and ac.HasBuff("Freecure") then ac.CastChannel(th,ac.actions.Cure2) end
            if ac.flags.canheal and th.hp.percent < ac.settings.hpthreshold2 then ac.CastChannel(th,ac.actions.Cure) end
        end
        if ac.IsAOEGood(ac.range.aoe) then
            ac.CastChannel(Player,ac.actions.Holy)
        end
        if ts then
            if Player:IsMoving() or not ac.HasDOT(ts,1) then ac.CastInstant(ts,ac.actions.Aero) end
            ac.CastChannel(ts,ac.actions.Stone)
        end

    end
end
function ac.DrawCircle(pos,radius,color,segments) --for AOE detection and drawing functionality to come
    local sx, sy = ac.W2S(pos)
    local n = (2*math.pi*radius/segments)
    local angle = n / radius local currentangle = 0
    local sppx = 0 local sppy = 0 local sfx = 0 local sfy = 0
    for i = 1, segments, 1 do
        local px = pos.x + (radius * math.sin(currentangle))
        local pz = pos.z + (radius * math.cos(currentangle))
        local spx, spy = ac.W2S({x=px,y=pos.y,z=pz})
        if i == 1 then
            sfx = spx sfy = spy
        elseif i < segments then
            GUI:AddTriangleFilled(sx,sy,spx,spy,sppx,sppy,color)
        else
            GUI:AddTriangleFilled(sx,sy,spx,spy,sppx,sppy,color)
            GUI:AddTriangleFilled(sx,sy,sfx,sfy,spx,spy,color)
        end
        sppx = spx sppy = spy
        currentangle = currentangle + angle
    end
end
function ac.DrawHitbox()
    --GUI:PushStyleColor(GUI.Col_WindowBg, ac.Color(1,1,1,1))
    GUI:PushStyleVar(GUI.StyleVar_Alpha,0.01)
    --local sw = GetGameSettings()[18].value*2.2 local sh = GetGameSettings()[19].value*2
    local sw = 2556 local sh = 1440
    GUI:SetNextWindowSize(sw,sh)
    GUI:Begin("Hitbox", true, GUI.WindowFlags_NoInputs + GUI.WindowFlags_NoTitleBar + GUI.WindowFlags_NoResize + GUI.WindowFlags_NoFocusOnAppearing + GUI.WindowFlags_NoBringToFrontOnFocus + GUI.WindowFlags_NoMove)
    spos = RenderManager:WorldToScreen(Player.pos)
    if MGetTarget() then
        tpos = RenderManager:WorldToScreen(MGetTarget().pos)
    else
        tpos = nil
    end
    if spos then
        GUI:SetWindowPos(spos.x-sw/2,spos.y-sh/2)
        -- local t = Player:GetTarget()
        -- if t and table.valid(t.pos) then 
        --     --ac.DrawCircle(t.pos,t.distance2d,ac.Color(0,.7,.9,.1),16)
        --     --d("T id:"..tostring(t.id).." Tpos: "..string.format("%.2f - %.2f - %.2f", t.pos.x, t.pos.y, t.pos.z))
        -- end
        --local el = EntityList("maxdistance2d=25")
        -- for i, e in pairs(el) do
        --     if not e.attackable and not e.targetable then
        --         ac.DrawCircle(e.pos, 1, ac.Color(.5,.5,0,.3),16)
        --     end
        -- end
        if not ac.settings.autolevel then
            GUI:AddCircleFilled(spos.x,spos.y,5,GUI:ColorConvertFloat4ToU32(1/255, 1/255, 1/255, 1),8)
            GUI:AddCircleFilled(spos.x,spos.y,2,GUI:ColorConvertFloat4ToU32(1, 1, 1, 1),8)
        end
    end
    if (ac.IsTank() or ac.IsMelee()) and ac.settings.autocombat and table.valid(MGetTarget()) and MGetTarget().distance2d > ac.range.basic then ac.DrawCircle(MGetTarget().pos,ac.range.basic,ac.Color(0,1,1,.1),16) end
    if Player.Incombat and ac.flags.lastaction == ac.actions.Disembowel and Player.level >= 50 then
        GUI:SetWindowFontSize(2)
        GUI:AddText(spos.x-100,spos.y+30,ac.Color(1,1,.1,1),"Aim for REAR!")
        GUI:SetWindowFontSize(1)
    end
    --GUI:PopStyleColor()
    GUI:PopStyleVar()
    GUI:End()
end
function ac.Draw()
    local open, visible = true, true
    if(open) then
        if Player.Incombat then
            GUI:PushStyleColor(GUI.Col_WindowBg,.4,.07,.07,1)
        else
            GUI:PushStyleColor(GUI.Col_WindowBg,0,.05,.05,1)
        end

        if ac.settings.debug then GUI:SetNextWindowSize(320, 510) else GUI:SetNextWindowSize(124, 124) end
        GUI:PushStyleVar(GUI.StyleVar_Alpha,1)
        visible, open = GUI:Begin("EASE Core", open, GUI.WindowFlags_NoResize+GUI.WindowFlags_NoCollapse)
        if(visible) then
            GUI:PopStyleColor(1)
            local toggleautocombat
            local togglepullmode
            local autocombat
            if (ac.IsSupported()) then GUI:Text(ac.GetJob().." is READY!") else GUI:Text("Coming SOON...") end
            if (ac.settings.autocombat) then
                if ac.IsSupported() then
                    autocombat = GUI:ImageButton("#Activator",GetLuaModsPath().."\\EASECore\\on.jpg",100,43)
                else
                    autocombat = GUI:ImageButton("#Activator",GetLuaModsPath().."\\EASECore\\soon.jpg",100,43)
                end
            else
                autocombat = GUI:ImageButton("#Activator",GetLuaModsPath().."\\EASECore\\off.jpg",100,43)
            end
            if GUI:IsItemHovered() then
                if ac.settings.autocombat then
                    GUI:BeginTooltip()
                    GUI:TextColored(ac.style.cyan.r,ac.style.cyan.g,ac.style.cyan.b,1,"verion "..ac.constants.version)
                    GUI:TextColored(1,1,1,1,"\nCurrently Supported:")
                    GUI:TextColored(ac.style.green.r,ac.style.green.g,ac.style.green.b,1,"BARD - 100%%")
                    GUI:TextColored(ac.style.yellow.r,ac.style.yellow.g,ac.style.yellow.b,1,"ASTROLOGIAN - 55%%\nBLACK MAGE - 55%%\nDARK KNIGHT - 55%%\nDRAGOON - 55%%\nMACHINIST - 55%%\nPALADIN - 55%%\nSCHOLAR - 55%%\nSUMMONER - 30%%\nWARRIOR - 50%%\nWHITE MAGE - 55%%\n")
                    GUI:TextColored(ac.style.orange.r,ac.style.orange.g,ac.style.orange.b,1,"SAGE - 20%% - NOT READY YET")
                    GUI:TextColored(ac.style.red.r,ac.style.red.g,ac.style.red.b,1,"GUNBREAKER - 0%% - TODO\nMONK - 0%% - TODO\nNINJA - 0%% - TODO\nSAMURAI - 0%% - TODO\nREAPER - 0%% - TODO\nDANCER - 0%%\nRED MAGE - 0%% - TODO")
                    GUI:Text("\nAdd me on Discord for support\nand requests")
                    GUI:TextColored(ac.style.cyan.r,ac.style.cyan.g,ac.style.cyan.b,1,"-Alchael")
                    GUI:Text("\n-P.S. Thank you so much\nfor trying me out. Take care :]")
                    GUI:TextColored(ac.style.green.r,ac.style.green.g,ac.style.green.b,1,"[LEFT CLICK to Disable EASECore]")
                    GUI:TextColored(ac.style.cyan.r,ac.style.cyan.g,ac.style.cyan.b,1,"[RIGHT CLICK to Join My Discord]")
                    GUI:EndTooltip()
                else
                    GUI:BeginTooltip()
                    GUI:Text("The EASE Series Upholds The Tenets of\nEfficiency\n        Affordability\n                Simplicity\n                        Elegance")
                    GUI:TextColored(ac.style.yellow.r,ac.style.yellow.g,ac.style.yellow.b,1,"INFO: SUPPORT is in my discord -Alchael")
                    GUI:TextColored(ac.style.green.r,ac.style.green.g,ac.style.green.b,1,"[LEFT CLICK to Enable EASECore!]")
                    GUI:TextColored(ac.style.cyan.r,ac.style.cyan.g,ac.style.cyan.b,1,"[RIGHT CLICK to Join My Discord]")
                    GUI:EndTooltip()
                end
            end
            if GUI:IsItemClicked(1) then
                local discord = io.popen(GetLuaModsPath().."\\EASECore\\discord.bat")
                d("ERRR?")
            end
            -- ac.settings.pullmode, togglepullmode = GUI:Checkbox("Pull Mode", ac.settings.pullmode)
            -- if toggleautocombat or togglepullmode then ac.SaveSettings() end
            if (autocombat) then
                ac.settings.autocombat = not ac.settings.autocombat
                if ac.settings.exclusive and ac.settings.autocombat and FFXIV_Common_BotRunning then ml_global_information:ToggleRun() end
                ac.SaveSettings()
            end
            local cbAutolevel, pAutolevel = GUI:Checkbox("A2Lvl", ac.settings.autolevel) if GUI:IsItemHovered() then
                local dungeons = ""
                for i, e in pairs(ac.maps) do
                    dungeons = dungeons.."\n"..e
                end
                GUI:BeginTooltip()
                GUI:TextColored(ac.style.cyan.r,ac.style.cyan.g,ac.style.cyan.b,1,"Auto Leveller - Dungeon Crawler\n")
                GUI:TextColored(1,1,1,1,"\nAlways bring tons of\nGrade 8 Dark Matter\nin your bag for auto\nrepairs and ensure\nthe addon can autolevel\nfor a long time.\n\n")
                GUI:TextColored(ac.style.yellow.r,ac.style.yellow.g,ac.style.yellow.b,1,"Currently SUPPORTED DUNGEONS:\n")
                GUI:TextColored(ac.style.green.r,ac.style.green.g,ac.style.green.b,1,dungeons)
                GUI:EndTooltip()
            end
            if pAutolevel then ac.settings.autolevel = not ac.settings.autolevel Player:Stop() ac.SaveSettings() end
            if ac.settings.autolevel and ac.IsInDungeon() then
                local progress = 100/#ac.todo*ac.flags.missionindex
                GUI:SameLine() GUI:Text(""..string.format("%.1f",progress).."%%")
            end

            -- DEBUG DEBUG DEBUG
            if ac.settings.debug and ac.InGame() then
                GUI:Text("mapid:"..tostring(Player.localmapid)) GUI:SameLine()
                local duty = FileLoad(GetLuaModsPath().."EASECore\\maps\\dev\\"..tostring(Player.localmapid)..".lua") or {}
                local bRecord = GUI:Button("Rec") GUI:SameLine() GUI:Text("x:"..string.format("%.2f",Player.pos.x).." y:"..string.format("%.2f",Player.pos.y).." z:"..string.format("%.2f",Player.pos.z))
                if MGetTarget() then
                    GUI:Text("Dist:"..string.format("%.2f",ac.GetDistance(Player.pos,MGetTarget().pos)))
                    GUI:SameLine() GUI:Text("Dist2D: "..string.format("%.2f",MGetTarget().distance2d))
                end
                if bRecord then
                    local t = MGetTarget() or Player
                    local type = t.id ~= Player.id
                    if t.name == Player.name then t.name = "Player" end d(t.name)
                    table.insert(duty, {type, tonumber(string.format("%.2f",t.pos.x)) , tonumber(string.format("%.2f",t.pos.y)), tonumber(string.format("%.2f",t.pos.z)), t.name})
                    FileSave(GetLuaModsPath().."EASECore\\maps\\dev\\"..tostring(Player.localmapid)..".lua", duty)
                    d("Recorded!")
                end
                if MGetTarget() then
                    GUI:SameLine()
                    GUI:Text("ID: "..tostring(MGetTarget().id))
                end
                GUI:Text("lastcombat:"..tostring(TimeSince(ac.flags.lastcombat))) GUI:SameLine() GUI:Text("mIndex:"..tostring(ac.flags.missionindex))
                
                GUI:SameLine() GUI:Text("stuck:"..tostring(ac.flags.stuck).." for:"..tostring(ac.flags.stucktime))
                
                GUI:Text("Job: "..tostring(Player.job)) GUI:SameLine()
                GUI:Text("Idle: "..string.format("%.2f",ac.flags.idletime)) GUI:SameLine()
                GUI:Text("Moving: "..tostring(ac.flags.movetime)) GUI:SameLine()
                GUI:Text("Boss: "..tostring(ac.IsInBossDungeon()))
                GUI:Text("AOE: "..tostring(ac.flags.canaoe)) GUI:SameLine()
                GUI:Text("Interrupt: "..tostring(ac.flags.caninterrupt)) GUI:SameLine()
                GUI:Text("Weave: "..tostring(ac.flags.canweave))
                GUI:Text("Loading: "..tostring(not Player.targetable)) GUI:SameLine()
                
                if (table.valid(Player:GetTarget())) then
                    ac.flags.toughness = Player:GetTarget().hp.max / Player.hp.max
                end
                GUI:Text("Tough: "..string.format("%.2f", ac.flags.toughness)) GUI:SameLine()
                GUI:Text("Boss: "..tostring(ac.flags.bosstarget))
                local t = Player:GetTarget()
                if(t ~= nil) then
                    GUI:Text("Target: "..tostring(t.name))
                    --Player:SetFacing(t.pos.x,t.pos.y,t.pos.z,true)
                    GUI:Text("Positional: "..tostring(ac.GetPositional(t)))
                   -- GUI:Text("Cone: "..tostring(ac.EnemiesInsideCone(ac.range.cone,t))) GUI:SameLine()
                    local rad = math.atan2(t.pos.x-Player.pos.x, t.pos.z-Player.pos.z)
                    GUI:Text("Rad: "..string.format("%.2f",rad)) GUI:SameLine() GUI:Text("Deg: "..string.format("%.2f",math.deg(rad)))
                    --GUI:Text("DOT1: "..tostring(ac.HasDOT1(t)).." DOT2: "..tostring(ac.HasDOT2(t)))
                end
                --local c1 = ac.GetMaxEnemiesInsideConePoint(12)
                if (c1) then
                    GUI:Text("Cone2: "..tostring(c1.id).." Count: "..tostring(c1.ents))
                end
                --local t = ac.GetMaxEnemiesInsideRadiusRangePoint(5,10)
                
                GUI:Text("Damaged: "..tostring(ac.flags.damagedfriends)) GUI:SameLine()
                GUI:Text("Friends: "..tostring(#ac.entities.friends)) GUI:SameLine()
                GUI:Text("TD: "..tostring(ac.flags.teamdamage)) GUI:SameLine()
                GUI:Text("AOEHG: "..tostring(ac.IsAOEHealGood()))
                local pos = Player.pos
                GUI:Text("H:"..string.format("%.2f",Player.camera.h).." P:"..string.format("%.2f",Player.camera.pitch).." x:"..string.format("%.2f",Player.camera.x).." y:"..string.format("%2.f",Player.camera.y).." z:"..string.format("%.2f",Player.camera.z))
                --czoom = GetGameSettings()[200].value
                --if czoom == nil then d("[EASECore]-Something wrong with minion, can't query CameraZoom!") end
                cdeg = -1*(math.deg(Player.camera.pitch)-5)
                GUI:Text("cdeg:"..string.format("%2.f",cdeg).." czoom:"..tostring(czoom))
                if ac.targets.manual then GUI:Text("manual:"..tostring(ac.targets.manual.name)) end
                if not ac.flags.lastaction then GUI:Text("lastaction:"..tostring(ac.flags.lastaction)) end
                local mx, my = ac.W2S(GetMouseInWorldPos())
                GUI:Text("mx:"..tostring(mx).." my:"..tostring(my).." driving:"..tostring(PlayerDriving()))
                GUI:Text("queue:"..string.format("%.2f",ac.flags.queue).." gcd:"..string.format("%.2f",ac.flags.gcd).." last gcd:"..tostring(TimeSince(ac.timer.gcd.last)))
                GUI:Text("canweave:"..tostring(ac.flags.canweave).." lastweave:"..tostring(ac.flags.lastweave))
                GUI:Text("canpoll:"..tostring(ac.flags.canpoll).." lastpoll:"..tostring(TimeSince(ac.timer.poll.last)))
                GUI:Text("polled:"..tostring(ac.poll.gcd).." lastaction:"..tostring(Player.castinginfo.lastcastid))
                GUI:Text("avoiding:"..tostring(ac.flags.avoiding).." lastheal:"..tostring(TimeSince(ac.timer.heal.last)).." sleep:"..tostring(ac.flags.sleep))
                --local x, y = RenderManager:WorldToScreen({pos.x,pos.y,pos.z}, true)
                --GUI:Text("x: "..tostring(x).." y: "..tostring(y))
                --GUI:AddCircleFilled( x/2, 1-y, 100,GUI:ColorConvertFloat4ToU32(0.9,0.1,0.12,0.5),32)
            end
        end
        GUI:End()
        GUI:PopStyleVar(1)
        if ac.settings.autocombat then ac.DrawHitbox() end
    end
end
function ac.GetDistance(ppos,tpos) return math.sqrt((tpos.x-ppos.x )^2 + (tpos.y-ppos.y)^2 + (tpos.z-ppos.z)^2) end
function ac.GetEnemiesInsideCone(radius, heading, wide)
    --local w = wide or true
    local el = nil
    local entities = nil
    el = MEntityList("alive,attackable,targetable,maxdistance2d="..tostring(ac.range.cone))
    entities = {}
    for _, e in pairs(el) do
        if (e.attackable and e.targetable) then
            local target = e
            local entityHeading = nil
            if (heading < 0) then entityHeading = heading + 2 * math.pi else entityHeading = heading end
            local targetPos = target.pos
            local entityAngle = math.atan2(targetPos.x - Player.pos.x, targetPos.z - Player.pos.z) 
            local deviation = entityAngle - entityHeading
            local absDeviation = math.abs(deviation)
            local leftover = math.abs(absDeviation - math.pi)
            if wide and (leftover > (math.pi * .75) and leftover < (math.pi * 1.25)) then
                table.insert(entities, e) -- entity is in front
            elseif not wide and (leftover > (math.pi * .63) and leftover < (math.pi * 1.37)) then
                table.insert(entities, e) -- narrow cone
            end
        end
    end
    ac.flags.enemiesinsidecone = #entities
    return #entities
end
function ac.GetEnemiesInsideRadius(radius)
    local el = EntityList("alive,attackable,targetable,maxdistance2d="..tostring(radius))
    local entities = {}
    for _, e in pairs(el) do table.insert(entities, e) end
    return entities
end
function ac.GetEntity(name,range)
    local el,t  = EntityList("maxdistance2d="..tostring(range)),nil
    for i, e in pairs(el) do
        if e.name == name then t = e return t end
    end
end
function ac.GetDeadFriends(radius)
    local el = EntityList.myparty or EntityList.crossworldparty
    if #el == 0 then
        el = EntityList("targetable,chartype=9,maxdistance=30")
    end
    local deadfriends = {}
    for _, e in pairs(el) do
        if (not e.alive and ac.GetDistance(Player.pos,e.pos) < radius and e.hp.percent == 0) then table.insert(deadfriends, e) end
    end
    return deadfriends
end
function ac.GetFriends(radius)
    local el = EntityList.myparty or EntityList.crossworldparty
    if #el == 0 then
        el = EntityList("alive,targetable,chartype=9,maxdistance=30")
    end
    local friends = {} table.insert(friends,Player)
    ac.flags.damagedfriends = 0
    for _, e in pairs(el) do
        if (ac.GetDistance(Player.pos,e.pos) < radius) then
            table.insert(friends, e)
            if (e.hp.percent <= ac.settings.hpthreshold1) then
                ac.flags.damagedfriends = ac.flags.damagedfriends + 1
            end
        end
    end
    table.sort(friends, function(l,r) return (l.hp.percent) < (r.hp.percent) end)
    return friends
end
function ac.GetHeading(target)
    ac.flags.heading = math.atan2(target.pos.x-Player.pos.x,target.pos.z-Player.pos.z)
    return ac.flags.heading
end
function ac.GetJob()
    if ac.IsAstrologian() then return "ASTro" end
    if ac.IsBard() then return "BaRD" end
    if ac.IsBlackMage() then return "BLMage" end
    if ac.IsDarkKnight() then return "DRKnt" end
    if ac.IsDragoon() then return "DRGoon" end
    if ac.IsMachinist() then return "MCHnst" end
    if ac.IsPaladin() then return "PLDin" end
    if ac.IsSage() then return "SaGE" end
    if ac.IsScholar() then return "SCHlr" end
    if ac.IsSummoner() then return "SMNer" end
    if ac.IsWarrior() then return "WARior" end
    if ac.IsWhiteMage() then return "WHMage" end
end
function ac.GetManualTarget()
    if ac.targets.manual then Player:SetTarget(ac.targets.manual.id)
    elseif ac.targets.manualheal then Player:SetTarget(ac.targets.manualheal.id)
    elseif ac.targets.manualrevive then Player:SetTarget(ac.targets.manualrevive.id)
    else Player:ClearTarget() end
end
function ac.GetMaxEnemiesInsideConePoint(radius,wide)
    local el = MEntityList("alive,attackable,targetable,maxdistance2d="..tostring(ac.range.cone))
    local enemycone = {}
    if (el) then
        for _, e in pairs(el) do
            if (e.attackable and e.targetable and e.aggro) then
                local numEnts = ac.GetEnemiesInsideCone(radius, ac.GetHeading(e),wide)
                table.insert(enemycone, {id=e.id, ents=numEnts, pos=e.pos, distance2d=e.distance2d})
            end
        end
        if (#enemycone > 1) then table.sort(enemycone, function(l,r) return (l.ents) > (r.ents) end) end
        return enemycone[1]
    end
end
function ac.GetBoss(range)
    local el = EntityList("alive,attackable,targetable,aggressive,maxdistance2d="..tostring(range))
    local boss = {}
    for _, e in pairs(el) do
        if (e.incombat and e.attackable and e.targetable and e.distance2d < range) then
            table.insert(boss, e)
        end
    end
    return boss[1]
end
function ac.GetMaxEnemiesInsideRadiusRangePoint(radius, range)
    local el = EntityList("alive, attackable, targetable")
    local enemyrangecircle = {}
    local entities = {}
    for _, e in pairs(el) do
        if (e.distance2d < range + radius and e.attackable and e.targetable) then
            table.insert(entities, e)
        end
    end
    --d("ENTS: "..tostring(#entities))
    for _, e in pairs(entities) do
        local numEnts = 0
        for i, j in pairs(entities) do
            if (ac.GetDistance(e.pos,j.pos) <= radius and e.aggro and e.distance2d < range) then
                numEnts = numEnts + 1
                --d("ADDED TO ENT "..tostring(numEnts).." id:"..tostring(e.id))
            end
        end
        if (numEnts > 0) then
            table.insert(enemyrangecircle,{buffs=e.buffs,id=e.id,ents=numEnts,pos=e.pos,distance2d=e.distance2d})
        end
    end
    --d("EENTS "..tostring(#enemyrangecircle))
    if (#enemyrangecircle > 1) then
        table.sort(enemyrangecircle, function(l,r) return (l.ents) > (r.ents) end)
    end
    --d(enemyrangecircle[1].id)
    return enemyrangecircle[1]
end
function ac.GetMobsInRange(range,incombat)
    local el = EntityList("alive,attackable,maxdistance2d="..tostring(range))
    ac.entities.enemies = {}
    for _, e in pairs(el) do
        if (e.incombat == incombat and (true or e.name == "Striking Dummy") and e.distance2d < range and e.los2) then
            table.insert(ac.entities.enemies, e)
        end
    end
    return ac.entities.enemies
end
function ac.GetPositional(target)
    if (IsFront(target,false)) then return "front"
    elseif (IsFlanking(target,false)) then return "flank"
    elseif (IsBehind(target,false)) then return "rear" end
    return "undefined"
end
function ac.GetPrioritySingleHeal()
    ac.entities.friends = ac.GetFriends(ac.range.heal)
    return ac.entities.friends[1] or Player
end
function ac.GetPrioritySingleRevive()
    ac.entities.deadfriends = ac.GetDeadFriends(ac.range.heal)
    table.sort(ac.entities.deadfriends, function(l,r) return (ac.IsTank(l)) and not (ac.IsTank(r)) end)
    table.sort(ac.entities.deadfriends, function(l,r) return (ac.IsHealer(l)) and not (ac.IsHealer(r)) end)
    return ac.entities.deadfriends[1]
end
function ac.GetPrioritySingleTarget()
    local angrymobs = {}
    if ac.IsBard() or ac.IsDragoon() then
        angrymobs = ac.GetMobsInRange(ac.range.basic,true)
        table.sort(angrymobs, function(l,r) return (l.hp.current) < (r.hp.current) end)
        --table.sort(angrymobs, function(l,r) return () < () end)
        table.sort(angrymobs, function(l,r) return not (ac.HasDOT(l,1) and ac.HasDOT(l,2)) and (ac.HasDOT(r,1) and ac.HasDOT(r,2)) end)
        table.sort(angrymobs, function(l,r)
            local dotl1, ownerl1, durl1 = ac.HasDOT(l,1) local dotl2, ownerl2, durl2 = ac.HasDOT(l,2) local dotr1, ownerr1, durr1 = ac.HasDOT(r,1) local dotr2, ownerr2, durr2 = ac.HasDOT(r,2)
            if not durl1 then durl1 =0 end if not durl2 then durl2 =0 end if not durr1 then durr1 =0 end if not durr2 then durr2 =0 end
            return (durl1 < ac.settings.dotrefresh or durl2 < ac.settings.dotrefresh) and not (durr1 < ac.settings.dotrefresh or durr2 < ac.settings.dotrefresh) end)
    end
    if ac.IsHealer() or ac.IsCaster() then
        angrymobs = ac.GetMobsInRange(ac.range.basic,true)
        table.sort(angrymobs, function(l,r) return (l.hp.current) < (r.hp.current) end)
        table.sort(angrymobs, function(l,r) return not (ac.HasDOT(l,1)) and (ac.HasDOT(r,1)) end)
    end
    if ac.IsMachinist() then
        angrymobs = ac.GetMobsInRange(ac.range.basic,true)
        table.sort(angrymobs, function(l,r) return (l.hp.current) < (r.hp.current) end)
    end
    if ac.IsTank() then
        angrymobs = ac.GetMobsInRange(ac.range.long,true)
        table.sort(angrymobs, function(l,r) return (l.distance2d) < (r.distance2d) end)
        table.sort(angrymobs, function(l,r) return (l.aggropercentage) < (r.aggropercentage) end)
        table.sort(angrymobs, function(l,r) return not (l.aggro) and (r.aggro) end)
    end
    
    return angrymobs[1]
end
function ac.GetPriorityTankPoke()
    if ac.IsTank() then
        local innocentmobs = ac.GetMobsInRange(ac.range.long,false)
        return innocentmobs[1]
    end
end
function ac.GetTeamDamageReached(damage) if (damage >= ac.flags.teamdamage) then return true else return false end end
function ac.GetToughness(target)
    ac.flags.toughness = 0
    if target ~= nil then ac.flags.toughness = target.hp.max / Player.hp.max end
    return ac.flags.toughness
end
function ac.HasBuff(name, target)
    local target = target or Player
    if (table.valid(target.buffs)) then
        for k, v in pairs(target.buffs) do
            local found = nil
            if (v.name == name) then
                return true, v.ownerid, v.duration
            end
        end
    end
    return false, "none", 0
end
function ac.HasDOT(target,dotnum) -- this whole thing needs refactoring
    if ac.IsAstrologian() then
        if dotnum == 1 then
            local a,b,c = ac.HasBuff("Combust",target) local d,e,f = ac.HasBuff("Combust II",target)
            if Player.level < 46 then return a and b == Player.id else return d and e == Player.id end
        end
    end
    if ac.IsBard() then
        if dotnum == 1 then
            local a,b,c = ac.HasBuff("Venomous Bite",target) local d,e,f = ac.HasBuff("Caustic Bite",target)
            if Player.level < 64 then return a and b == Player.id else return d and e == Player.id end
        elseif dotnum == 2 then
            local a,b,c = ac.HasBuff("Windbite",target) local d,e,f = ac.HasBuff("Stormbite",target)
            if Player.level < 64 then return a and b == Player.id else return d and e == Player.id end
        end
    end
    if ac.IsBlackMage() then
        if dotnum == 1 then
            local a,b,c = ac.HasBuff("Thunder",target) local d,e,f = ac.HasBuff("Thunder III",target)
            if Player.level < 45 then return a and b == Player.id else return d and e == Player.id end
        elseif dotnum == 2 then
            local a,b,c = ac.HasBuff("Thunder II",target) local d,e,f = ac.HasBuff("Thunder IV",target)
            if Player.level < 64 then return a and b == Player.id else return d and e == Player.id end
        end
    end
    if ac.IsScholar() then
        if dotnum == 1 then
            local a,b,c = ac.HasBuff("Bio",target) local d,e,f = ac.HasBuff("Bio II",target)
            if Player.level < 26 then return a and b == Player.id else return d and e == Player.id end
        end
    end
    if ac.IsWhiteMage() then
        if dotnum == 1 then
            local a,b,c = ac.HasBuff("Aero",target) local d,e,f = ac.HasBuff("Aero II",target)
            if Player.level < 46 then return a and b == Player.id else return d and e == Player.id end
        end
    end
end
function ac.InitDungeon()
    gSkipTalk = true
    ac.flags.lastcombat = Now()
    ac.flags.missionindex = ac.settings.missionindex
    local objectives = FileLoad(GetLuaModsPath().."\\EASECore\\maps\\"..tostring(Player.localmapid)..".lua")
    ac.todo = {}
    for i, e in pairs(objectives) do
        table.insert(ac.todo, {e, done = false} )
    end
end
function ac.InitJob()
    if ac.IsRange() then
        ac.range.aoeheal = 30
        ac.range.basic = 25.0
        ac.range.buff = 30.0
        ac.range.cone = 12
    end
    if ac.IsDragoon() then
        ac.range.basic = 3
        ac.range.cone = 7
        ac.range.jump = 20
        ac.range.jumpmin = 13
    end
    if ac.IsTank() then
        ac.range.basic = 3
        ac.range.cone = 7
        ac.range.short = 5
        ac.range.long = 20
    end
    if ac.IsHealer() then
        ac.range.aoe = 8
        ac.range.aoeheal = 15
        ac.range.basic = 25
        ac.range.heal = 30
    end
    if ac.IsSummoner() or ac.IsBlackMage() then
        ac.range.basic = 25
        ac.range.heal = 30
    end
end
function ac.InGame() return MGetGameState() == FFXIV.GAMESTATE.INGAME end
function ac.IsActionReady(action) return (action.level <= Player.level and not action.isoncd) end
function ac.IsAOECandidate(target) if (target and target.ents >= ac.settings.aoethreshold) then return target else return false end end
function ac.IsAOEGood(radius) return #ac.GetEnemiesInsideRadius(radius) >= ac.settings.aoethreshold end
function ac.IsAOEHealGood() if #ac.entities.friends ~= 0 then return (ac.flags.damagedfriends >= #ac.entities.friends/2) end end
function ac.IsCombo(action) return ac.flags.lastaction == action end
function ac.IsAstrologian(target) local t = target or Player return t.job == FFXIV.JOBS.ASTROLOGIAN end
function ac.IsBard(target) local t = target or Player return t.job == FFXIV.JOBS.ARCHER or t.job == FFXIV.JOBS.BARD end
function ac.IsBlackMage(target) local t = target or Player return t.job == FFXIV.JOBS.THAUMATURGE or t.job == FFXIV.JOBS.BLACKMAGE end
function ac.IsDarkKnight(target) local t = target or Player return t.job == FFXIV.JOBS.DARKKNIGHT end
function ac.IsDragoon(target) local t = target or Player return t.job == FFXIV.JOBS.LANCER or t.job == FFXIV.JOBS.DRAGOON end
function ac.IsMachinist(target) local t = target or Player return t.job == FFXIV.JOBS.MACHINIST end
function ac.IsMonk(target) local t = target or Player return t.job == FFXIV.JOBS.PUGILIST or t.job == FFXIV.JOBS.MONK end
function ac.IsNinja(target) local t  = target or Player return t.job == FFXIV.JOBS.ROGUE or t.job == FFXIV.JOBS.NINJA end
function ac.IsPaladin(target) local t = target or Player return t.job == FFXIV.JOBS.GLADIATOR or t.job == FFXIV.JOBS.PALADIN end
function ac.IsRedMage(target) local t = target or Player return t.job == FFXIV.JOBS.REDMAGE end
function ac.IsSage(target) local t = target or Player return t.job == FFXIV.JOBS.SAGE end
function ac.IsScholar(target) local t = target or Player return t.job == FFXIV.JOBS.SCHOLAR end
function ac.IsSummoner(target) local t = target or Player return t.job == FFXIV.JOBS.ARCANIST or t.job == FFXIV.JOBS.SUMMONER end
function ac.IsWarrior(target) local t = target or Player return t.job == FFXIV.JOBS.MARAUDER or t.job == FFXIV.JOBS.WARRIOR end
function ac.IsWhiteMage(target) local t = target or Player return t.job == FFXIV.JOBS.CONJURER or t.job == FFXIV.JOBS.WHITEMAGE end
function ac.IsTank(target) local t = target or Player return ac.IsPaladin(t) or ac.IsWarrior(t) or ac.IsDarkKnight(t) end
function ac.IsHealer(target) local t = target or Player return ac.IsWhiteMage(t) or ac.IsScholar(t) or ac.IsAstrologian(t) or ac.IsSage(t) end
function ac.IsMelee(target) local t = target or Player return ac.IsDragoon(t) or ac.IsMonk(t) or ac.IsNinja(t) end
function ac.IsRange(target) local t = target or Player return ac.IsBard(t) or ac.IsMachinist(t) end
function ac.IsCaster(target) local t = target or Player return ac.IsSummoner(t) or ac.IsBlackMage(t) or ac.IsRedMage(t) end
function ac.IsCombatant(target) local t = target or Player return ac.IsTank(t) or ac.IsHealer(t) or ac.IsMelee(t) or ac.IsRange(t) or ac.IsCaster(t) end
function ac.IsOnline(target) return target.onlinestatus == 43 end
function ac.IsDOTexpiring(target,dotnum) -- needs refactoring
    if ac.IsBard() then
        if dotnum == 1 then
            local a, b, c = ac.HasBuff("Venomous Bite", target) local d, e, f = ac.HasBuff("Caustic Bite", target)
            if (Player.level >= 64) then return d and f < ac.settings.dotrefresh else return a and c < ac.settings.dotrefresh end
        elseif dotnum == 2 then
            local a, b, c = ac.HasBuff("Windbite", target) local d, e, f = ac.HasBuff("Stormbite", target)
            if (Player.level >= 64) then return d and f < ac.settings.dotrefresh else return a and c < ac.settings.dotrefresh end
        end
    end
end
function ac.IsCastingSomethingDangerous(target)
    ac.GetToughness(target)
    if target and table.valid(target) then if target.castinginfo.channeltime > ac.settings.dangerouscast and ac.flags.toughness > ac.settings.bosshpmultiplier then return true end end
end
function ac.IsCastingSomethingDangerousInterruptible(target)
    if ac.IsCastingSomethingDangerous(target) and target.castinginfo.castinginterruptible then return true end
end
function ac.IsStuck()
    local p = Player.pos local pp = ac.flags.prevpos
    if pp.x ~= nil and ac.GetDistance({x=p.x,y=p.y,z=p.z},{x=pp.x,y=pp.y,z=pp.z}) < ac.constants.stuckdistance and Player:IsMoving() then ac.timer.stuck.last = Now() return true end
    ac.flags.prevpos = Player.pos
end
function ac.IsSwiftcasted() if (ac.HasBuff("Swiftcast") or Player.castinginfo.lastcastid == ac.actions.Swiftcast) then return true else return false end end
function ac.IsValidAttackTarget()
    local target = MGetTarget()
    if (target and target.attackable) then --FUCKING LOS2 gave me a headache bug against Pandaemonium
        target.ents = 1
        ac.targets.manual = target
        return target
    else ac.targets.manual = nil return false end
end
function ac.IsValidHealTarget()
    local target = MGetTarget()
    if (target and target.alive and not target.attackable and target.los2) then ac.targets.manualheal = target return target else ac.targets.manualheal = nil return false end
end
function ac.IsValidReviveTarget()
    local target = MGetTarget()
    if (target and not target.alive and not target.attackable and target.los2) then ac.targets.manualrevive = target return target else ac.targets.manualrevive = nil return false end
end
function ac.IsInDungeon()
    for i, e in pairs(ac.maps) do if GetMapName(Player.localmapid) == e then return true end end
    return false
end
function ac.IsInBossDungeon()
    if (Duty:GetQueueStatus() == 4 and not table.valid(Duty:GetActiveDutyObjectives()) or #ac.entities.friends > 4) then
        return true
    end
    return false
end
function ac.IsSupported() if ac.IsAstrologian() or ac.IsBard() or ac.IsBlackMage() or ac.IsDarkKnight() or ac.IsDragoon() or ac.IsMachinist() or ac.IsPaladin() or ac.IsScholar() or ac.IsSummoner() or ac.IsWarrior() or ac.IsWhiteMage() then return true else return false end end
function ac.IsBLMYoked() local lc = Player.castinginfo.lastcastid if lc == ac.actions.Fire2 or lc == ac.actions.Fire3 or lc == ac.actions.Blizzard2 or lc == ac.actions.Blizzard3 then return true elseif ac.gauge.BLMumbraltype <= -2 or ac.gauge.BLMumbraltype >= 2 then return true else return false end end
function ac.IsBLMYoking() local lc = Player.castinginfo.channelingid if lc == ac.actions.Fire2 or lc == ac.actions.Fire3 or lc == ac.actions.Blizzard2 or lc == ac.actions.Blizzard3 then return true else return false end end
function ac.MoveToFront(target)
    local pos = GetPosFromDistanceHeading(target.pos, 1, target.pos.h)
    MoveDirectly3D(pos)
    --Player:MoveTo(pos.x,pos.y,pos.z)
end
function ac.MoveToRear(target)
    local targetheading = HeadingToDegrees(target.pos.h)
    targetheading = targetheading + 180
    if targetheading > 360 then targetheading = targetheading - 360 end
    targetheading = DegreesToHeading(targetheading)
    local pos = GetPosFromDistanceHeading(target.pos, 1, targetheading)
    MoveDirectly3D(pos)
    --Player:MoveTo(pos.x,pos.y,pos.z)
end
function ac.RestartDungeon() Player:Stop() ac.CastChannel(Player,ac.actions.Return) ac.settings.missionindex = 1 ac.SaveSettings() ac.InitDungeon() end
function ac.SaveSettings() local save = FileSave(GetLuaModsPath().."EASECore\\settings.ini", ac.settings) end
function ac.ToggleDebug() ac.settings.debug = not ac.settings.debug ac.SaveSettings() end
function ac.Update()
    -- TIME SLICES -- not Player.targetable means game is in between loading screen
    if TimeSince(ac.timer.breath.last) > ac.timer.breath.frequency and Player.targetable then ac.UpdateBreath() end
    if TimeSince(ac.timer.heartbeat.last) > ac.timer.heartbeat.frequency and Player.targetable then ac.UpdateHeartbeat() end
    if TimeSince(ac.timer.halfbeat.last) > ac.timer.halfbeat.frequency and Player.targetable then ac.UpdateHalfbeat() end
    if TimeSince(ac.timer.pulse.last) > ac.timer.pulse.frequency and Player.targetable then ac.UpdatePulse() end
    if ac.settings.autocombat then
        -- TICKS
        if ac.InGame() then
            if ac.IsAstrologian() then ac.CombatAstrologian() end
            if ac.IsBard() then ac.CombatBard() end
            if ac.IsBlackMage() then ac.CombatBlackMage() end
            if ac.IsDarkKnight() then ac.CombatDarkKnight() end
            if ac.IsDragoon() then ac.CombatDragoon() end
            if ac.IsMachinist() then ac.CombatMachinist() end
            if ac.IsPaladin() then ac.CombatPaladin() end
            if ac.IsSage() then ac.CombatSage() end
            if ac.IsScholar() then ac.CombatScholar() end
            if ac.IsSummoner() then ac.CombatSummoner() end
            if ac.IsWarrior() then ac.CombatWarrior() end
            if ac.IsWhiteMage() then ac.CombatWhiteMage() end
            ------------------
            ac.UpdateActions()
            ac.AutoFollow()
            ac.Avoidance()
        end
    end
    if ac.settings.autolevel and not ac.flags.hasinitdungeon and ac.IsInDungeon() then
        ac.InitDungeon()
        ac.flags.hasinitdungeon = true
    end
end
function ac.UpdateTeamHealth()
    ac.entities.friends = ac.GetFriends(ac.range.aoeheal)
    local teamdamage = 0
    for _, e in pairs(ac.entities.friends) do
        teamdamage = teamdamage + (100 - e.hp.percent)
    end
    ac.flags.teamdamage = teamdamage
end
function ac.UpdateActions()
    local a = ActionList:Get(1,ac.gcd[Player.job])
    ac.flags.queue = (a.recasttime - a.cd) * 1000
    ac.flags.gcd = a.cd * 1000
    -- Pop off those polled actions if successfully executed
    if (ac.poll.gcd == Player.castinginfo.lastcastid and TimeSince(ac.timer.gcd.last) > (ac.flags.gcd - ac.timer.poll.timeout)) then ac.poll.gcd = nil ac.timer.gcd.last = Now() end
    if (ac.poll.weave == Player.castinginfo.lastcastid and TimeSince(ac.timer.weave.last) > (ac.timer.weave.frequency)) or TimeSince(ac.timer.weave.last) > ac.timer.weave.timeout then ac.flags.lastweave = ac.poll.weave ac.poll.weave = nil ac.timer.weave.last = Now() end
    -- Special Flags
    if Player.castinginfo.lastcastid == ac.actions.SpineshatterDive or Player.castinginfo.lastcastid == ac.actions.DragonfireDive then ac.timer.jump.last = Now() end
    --if TimeSince(ac.timer.weave.last) > ac.timer.weave.timeout then ac.poll.weave = nil ac.flags.canweave = true end
    if TimeSince(ac.timer.poll.last) > a.recasttime*1000-ac.timer.poll.timeout then ac.poll.gcd = nil ac.flags.canpoll = true ac.timer.poll.last = Now() end
    
    if (ac.flags.queue < ac.timer.poll.timeout) then
        if ac.poll.gcd == nil then ac.flags.canpoll = true end
    elseif (ac.flags.queue > ac.timer.poll.timeout and a.cd > 0) then
        ac.flags.canpoll = false
        ac.flags.canweave = true
    end
    if ac.flags.queue <= ac.timer.weave.timeout then
        ac.flags.canweave = false
    end
    -- if ac.IsSummoner() then
    --     if ac.flags.queue < 800 then ac.flags.canweave = true end
    -- end

    -- Get new Poll if Poll failed
    if TimeSince(ac.timer.poll.last) > a.recasttime*1000 then ac.poll.gcd = nil ac.flags.canpoll = true ac.timer.poll.last = Now() end
    -- Block Polling if something's queued
    if ac.poll.gcd ~= nil then ac.flags.canpoll = false end
end
function ac.UpdateBreath()
    if Player.Incombat and ac.IsInDungeon() and ac.settings.autolevel then
        if IsControlOpen("SystemMenu") then UseControlAction("SystemMenu","Close") end
    end
end
function ac.UpdateCombo()
    local lc = Player.castinginfo.lastcastid
    for _, e in pairs(ac.combo) do
        if e == lc then ac.flags.lastaction = e end
    end
    for _,e in pairs(ac.heals) do
        if Player.castinginfo.lastcastid == e and TimeSince(ac.timer.heal.last) > ac.timer.heal.timeout + 1000 then ac.timer.heal.last = Now() end
    end
    if TimeSince(ac.timer.heal.last) > ac.timer.heal.timeout then ac.flags.canheal = true else ac.flags.canheal = false end
end
function ac.UpdateFlags()

end
function ac.UpdateGauge()
    if ac.IsSage() then
        ac.gauge.SGEcharges = Player.gauge[2]
        ac.gauge.SGEmeter = Player.gauge[1]
    end
    if ac.IsSummoner() then
        ac.gauge.SMNactivesummon = Player.gauge[9]
        ac.gauge.SMNaetherflow = Player.gauge[10]
        ac.gauge.SMNlockdown = Player.gauge[1]
        ac.gauge.SMNsummontime = Player.gauge[2]
        ac.gauge.SMNstacks = Player.gauge[3]
        ac.gauge.SMNruby = Player.gauge[5]
        ac.gauge.SMNtopaz = Player.gauge[6]
        ac.gauge.SMNemerald = Player.gauge[7]
    end
    if ac.IsScholar() then
        ac.gauge.SCHaetherflow = Player.gauge[1]
    end
    if ac.IsWarrior() then
        ac.gauge.WARbeast = Player.gauge[1]
    end
    if ac.IsDarkKnight() then
        ac.gauge.DRKdarkside = Player.gauge[2]
    end
    if ac.IsMachinist() then
        ac.gauge.MCHheat = Player.gauge[1]
        ac.gauge.MCHbattery = Player.gauge[2]
        ac.gauge.MCHoverheated = Player.gauge[3]
    end
    if ac.IsBlackMage() then
        ac.gauge.BLMumbraltype = Player.gauge[2]
        ac.gauge.BLMumbraltimer = Player.gauge[4]
    end
end
function ac.UpdateHalfbeat()
    ac.timer.halfbeat.last = Now()
    -- dungeon crawler
    if (ac.settings.autolevel and ac.flags.hasinitdungeon) then
        -- door pressers
        if IsControlOpen("SelectYesno") then
            local str = GetControlStrings("SelectYesno", 2)
            if string.find(str, "Enter") or string.find(str, "Read") or string.find(str, "Unlock") or string.find(str, "Press") or string.find(str, "Use") or string.find(str, "Open") or string.find(str, "Pull") or string.find(str, "Add") or string.find(str, "Activate") then UseControlAction("SelectYesno","Yes") end
        end
        if not Player.alive then d("[EASECore] - Game AI has beaten our AI... please report to @Alchael - or equip better gear to ensure success") ac.InitDungeon() ac.flags.missionindex = 1 end
        local mission = nil
        mission = ac.todo[ac.flags.missionindex]
        if mission == nil and Duty:GetActiveDutyInfo().timer < 5390 then
            d("WILL LEAVE NOW - NOTHING MORE TO SEE")
            if IsControlOpen("SelectYesno") and GetControlStrings("SelectYesno", 2) == "Abandon duty?" then
                UseControlAction("SelectYesno", "Yes")
            end
            if not IsControlOpen("ContentsFinderMenu") then
                local action = ActionList:Get(10,33):Cast() --duty menu
            else
                UseControlAction("ContentsFinderMenu", "Leave")
            end
        elseif mission.done then ac.flags.missionindex = ac.flags.missionindex + 1
        end
        local mobs = EntityList("alive,targetable,attackable,incombat,maxdistance2d=15")
        local ts = nil
        table.sort(mobs, function(l,r) return (l.hp.current) < (r.hp.current) end)
        ts = mobs[1] --d(mobs)
        --if ts then Player:Stop() Player:SetTarget(ts.id) end
        if ac.flags.lastcombat > 2000 and TimeSince(ac.flags.lastinteract) > 3000 then
            if mission and not Player.Incombat then
                local pos, t = {x=mission[1][2],y=mission[1][3],z=mission[1][4]}, nil
                if not mission[1][5] == "Player" then
                   local t = ac.GetEntity(mission[1][5],25)
                    d("[EASECore] - Go to target: "..tostring(t.name))
                    pos = t.pos
                end
                if mission[1][1] == true and ac.GetDistance(Player.pos,pos) < 4 then
                    local t = ac.GetEntity(mission[1][5],15)
                    if t == nil then
                        ac.flags.missionindex = ac.flags.missionindex + 1 d("BAD PATHING - SKIPPING!")
                    end
                    d("[EASECore] - Found Interact Target: ! "..tostring(t.name))
                    pos = t.pos
                    if ac.GetDistance(Player.pos,t.pos) < 4 then
                        Player:Stop()
                        if t then Player:Interact(t.id)
                            ac.flags.sleep = 2000
                            ac.flags.lastinteract = Now() -- hack to make us wait
                            d("[EASECore] - Interacting with..."..tostring(t.name))
                            ac.UpdateMission()
                        else
                            ac.flags.missionindex = ac.flags.missionindex - 1
                        end
                    end
                end
                if mission[1][1] == false and ac.GetDistance(Player.pos,pos) < 2 then --distance for gates
                    d("[EASECore] - REACHED Checkpoint "..tostring(ac.flags.missionindex))
                    Player:Move(FFXIV.MOVEMENT.FORWARD)
                    ac.UpdateMission()
                elseif ac.flags.sleep == 0 and not MIsCasting() then
                    if mission[1][5] ~= "Player" then
                        local t = ac.GetEntity(mission[1][5],25)
                        if t == nil then ac.flags.missionindex = ac.flags.missionindex + 1 else
                            d("[EASECore] - INTERACTABLE FOUND! - "..tostring(t.name).." @ x:"..string.format("%.2f",t.pos.x).." y:"..string.format("%.2f",t.pos.y).." z:"..string.format("%.2f",t.pos.z))
                            if ac.GetDistance(Player.pos,t.pos) < 4 then
                                Player:Stop()
                                if t then Player:Interact(t.id)
                                    if t.name ~= "Treasure Coffer" then -- ???
                                        ac.flags.sleep = 2000
                                        ac.flags.lastinteract = Now() -- hack to make us wait
                                    end
                                    d("[EASECore] - Interacting with..."..tostring(t.name))
                                    ac.UpdateMission()
                                end
                            else
                                Player:MoveTo(t.pos.x,t.pos.y,t.pos.z)
                            end
                        end
                    else
                        Player:MoveTo(pos.x,pos.y,pos.z)
                    end
                    local str = "" if mission[1][5] ~= "Player" then str = mission[1][5] end
                    if ac.flags.missionindex ~= ac.flags.prevmissionindex then d("[EASECORE] - Mission Step: "..tostring(ac.flags.missionindex).." "..tostring(str)) end
                end
            end
        end
        if ac.flags.stucktime > ac.timer.stuck.timeout and not Player.Incombat then ac.RestartDungeon() end
    end
end

function ac.UpdateHeartbeat()
    ac.timer.heartbeat.last = Now()
    if(not table.valid(ml_navigation.path) and Player.settings.movemode == 0) and not ac.settings.autolevel then Player:SetMoveMode(1) end
    if ac.settings.autolevel then Player:SetMoveMode(0) end
    if IsControlOpen("RecommendList") then UseControlAction("RecommendList","Close") end
    if IsControlOpen("PlayGuide") then UseControlAction("PlayGuide","Destroy") end
    local sprint = ActionList:Get(5,4)
    if (ac.flags.movetime >= 5 and ac.settings.autocombat and not sprint.isoncd and Player.Incombat == false and not IsMounted() and not ac.IsInBossDungeon()) then -- need proper logic here when to cast, preferrably trying to avoidAOE
        sprint:Cast()
    end
    --autorepair
    if ac.IsInDungeon() and ac.settings.autocombat and not ac.settings.repaired and not Player.Incombat and Player.targetable then
        if IsControlOpen("SelectYesno") and ac.flags.sleep == 0 then
            UseControlAction("SelectYesno","Yes")
            ac.settings.repair.last = Now()
            ac.settings.repaired = true
            ac.flags.repairwindow = false
            ac.settings.autolevel = true
            ac.SaveSettings()
            d("[EASECore] - REPAIR COMPLETE!")
        end
        if IsControlOpen("Repair") and ac.flags.sleep == 0 then
            GetControl("Repair"):DoAction(0) ac.flags.sleep = 3000
            if not ac.settings.repaired then d("[EASECore] - WILL NOW ATTEMPT REPAIR") end
        elseif not ac.flags.repairwindow then
            ActionList:Get(5,6):Cast()
            Player:Stop()
            ac.settings.autolevel = false
            ac.flags.repairwindow = true
        end
    end
    if ac.settings.repaired and TimeSince(ac.settings.repair.last) > ac.settings.repair.frequency then
        ac.settings.repaired = false ac.SaveSettings()
    end
    if ac.settings.repaired and IsControlOpen("Repair") then UseControlAction("Repair","Close") end
    --stuck check
    if ac.flags.stuck then ac.flags.stucktime = ac.flags.stucktime + 1 else ac.flags.stucktime = 0 end
    ac.flags.stuck = ac.IsStuck()
    --flags
    if Player.Incombat then ac.flags.lastcombat = Now() end
    if ac.flags.prevmapid ~= Player.localmapid then ac.flags.prevmapid = Player.localmapid end
    if Player.job ~= ac.flags.prevjob then ac.flags.prevjob = Player.job ac.InitJob() end

    if Player.Incombat ~= ac.flags.prevcombat then ac.flags.prevcombat = not ac.flags.prevcombat end
    if ac.flags.missionindex ~= ac.flags.prevmissionindex then ac.flags.prevmissionindex = ac.flags.missionindex end
    -- dungeon reset
    if not ac.IsInDungeon() then ac.flags.hasinitdungeon = false ac.settings.missionindex = 1 ac.flags.missionindex = 1 end
    -- bandaid
    --if ac.flags.stuck and ac.IsInDungeon() and ac.settings.autolevel then ActionList:Get(5,2):Cast() end -- jump like an idiot
    if ac.settings.autocombat and ac.IsSummoner() then if not table.valid(Player.pet) then ac.CastChannel(Player,ac.actions.SummonCarbuncle) end end
    if ac.settings.autocombat and ac.IsScholar() then if not table.valid(Player.pet) then ac.CastChannel(Player,ac.actions.SummonEos) end end
    -- can't have your cake and eat it too
    if ac.settings.exclusive and ac.settings.autocombat and FFXIV_Common_BotRunning then ac.settings.autocombat = false ac.SaveSettings() end
    -- CRAWL SOME DUNGEON
    if ac.IsSupported() and ac.settings.autocombat and ac.settings.autolevel and not ac.flags.hasinitdungeon and not ac.IsInDungeon() then
        if Player.level < 15 then d("[EASECore] - Level Up to at least 15 Before you can use AUTOLEVELER!") ac.settings.autolevel = false ac.SaveSettings() end
        local dutyindex = nil
        for i = Player.level, 1, -1 do
            if ac.dungeon[i] then
                dutyindex = ac.dungeon[i]
                break
            end
        end
        if IsControlOpen("ContentsFinderConfirm") then
            UseControlAction("ContentsFinderConfirm","Confirm")
        elseif IsControlOpen("DawnStory") then
            UseControlAction("DawnStory","SelectDuty",dutyindex)
            UseControlAction("DawnStory","Register",dutyindex)
            local maxlevel, maxitem = 0, 0
            table.sort(ac.dgitemlevel, function (l,r) return (l) < (r)end)
            for i, e in pairs(ac.dgitemlevel) do
                --d("i:"..tostring(i).." e:"..tostring(e))
                if i > maxlevel and Player.level >= i then maxlevel = i maxitem = e end
            end
            if IsControlOpen("DawnStory") and GetControlRawData("DawnStory",403).value < maxitem then
                d("[EASECore] - Cannot Join Current Highest Dungeon Level - Upgrade Your Gear!") ac.settings.autolevel = false ac.SaveSettings()
            else
                d("[EASECore] - Highest Doable Duty Support Dungeon Level: "..tostring(maxlevel).." - iLevel Requirement: "..tostring(maxitem).." - Commencing EASECore AutoLeveling...")
            end
        elseif dutyindex then
            ActionList:Get(10,91):Cast()
            ac.settings.missionindex = 1
        end
    end
end
function ac.UpdateMission()
    if not Player.Incombat then
        if ac.todo[ac.flags.missionindex] ~= nil then
            ac.todo[ac.flags.missionindex].done = true
        end
        ac.flags.missionindex = ac.flags.missionindex + 1
        ac.settings.missionindex = ac.flags.missionindex
        ac.SaveSettings()
    end
end
function ac.UpdatePositionals()
end
function ac.UpdatePulse()
    ac.timer.pulse.last = Now()
    if ac.flags.sleep > 0 then ac.flags.sleep = ac.flags.sleep - 100 end
    if ac.settings.autocombat and IsControlOpen("GrandCompanySupplyReward") then UseControlAction("GrandCompanySupplyReward","Deliver") end
    if Player:IsMoving() and ac.flags.ismoving then ac.flags.movetime = ac.flags.movetime + (ac.timer.pulse.frequency/1000) end
    if not Player:IsMoving() and not ac.flags.ismoving then ac.flags.idletime = ac.flags.idletime + (ac.timer.pulse.frequency/1000) end
    if Player:IsMoving() and not ac.flags.ismoving then ac.flags.ismoving = not ac.flags.ismoving ac.flags.idletime = 0
    elseif not Player:IsMoving() and ac.flags.ismoving then ac.flags.ismoving = not ac.flags.ismoving ac.flags.movetime = 0 end
    ac.UpdateCombo()
    ac.UpdateGauge()
    ac.UpdateSongs()
    ac.UpdateTarget()
    ac.UpdateTeamHealth()
    --Role Actions
    if ac.settings.autocombat then
        if ac.flags.canweave then
            local lt = ac.IsValidAttackTarget() or ac.targets.single
            if Player.Incombat then
                if ac.IsTank() then
                    if ac.IsCastingSomethingDangerousInterruptible(lt) then ac.CastWeave(lt,ac.actions.Interject) end
                    if lt and lt.hp.max > Player.hp.max * ac.settings.bosshpmultiplier or ac.IsAOEGood(ac.range.short) then
                        if Player.hp.percent < ac.settings.hpthreshold1 then ac.CastWeave(Player,ac.actions.Reprisal) end
                        if Player.hp.percent < ac.settings.hpthreshold2 then ac.CastWeave(Player,ac.actions.Rampart) end
                    end
                end
                if ac.IsHealer() then
                    if Player.mp.current < ac.settings.mphalf then ac.CastWeave(Player,ac.actions.LucidDreaming) end
                end
                if ac.IsMelee() or ac.IsRange() then if Player.hp.percent <= ac.settings.hpthreshold3 then ac.CastWeave(Player,ac.actions.SecondWind) end end
                if ac.IsMelee() then
                    if Player.hp.percent <= ac.settings.hpthreshold2 then ac.CastWeave(Player,ac.actions.Bloodbath) end
                    if ac.IsCastingSomethingDangerous(lt) then ac.CastWeave(lt,ac.actions.Feint) end
                end
                if ac.IsCaster() then
                    if not ac.IsBlackMage() and Player.mp.current < ac.settings.mphalf then ac.CastWeave(Player,ac.actions.LucidDreaming) end
                    --ac.GetToughness(ts)
                    if ac.IsCastingSomethingDangerous(lt) then ac.CastWeave(lt,ac.actions.Addle) end
                end
            end
        elseif not Player.Incombat then
            if ac.IsRange() and not ac.IsInBossDungeon() and not IsMounted() and not IsFlying() and not ac.HasBuff("Peloton") and ac.flags.movetime >= 1 then ActionList:Get(1,ac.actions.Peloton):Cast() end
        end
    end
end
function ac.UpdateSongs()
    if (ac.HasBuff("The Wanderer's Minuet")) then ac.flags.songlist = 2 return true end
    if (ac.HasBuff("Mage's Ballad")) then ac.flags.songlist = 3 return true end
    if (ac.HasBuff("Army's Paeon")) then ac.flags.songlist = 1 return true end
end
function ac.UpdateTarget()      -- Needs rework and abstraction.. but working for now
    if ac.IsRange() then
        --ac.entities.friends = ac.GetFriends(ac.range.heal)
        ac.targets.heal = ac.GetPrioritySingleHeal()
        ac.targets.cone = ac.GetMaxEnemiesInsideConePoint(ac.range.cone,true)
        ac.targets.rangecircle = ac.GetMaxEnemiesInsideRadiusRangePoint(ac.range.radiusRainOfDeath, ac.range.basic)
        ac.targets.single = ac.GetPrioritySingleTarget()
        ac.targets.boss = ac.GetBoss(ac.range.basic)
    end
    if ac.IsDragoon() then
        ac.targets.cone = ac.GetMaxEnemiesInsideConePoint(ac.range.cone,false)
        ac.targets.rangecircle = ac.GetMaxEnemiesInsideRadiusRangePoint(5, ac.range.jump)
        ac.targets.single = ac.GetPrioritySingleTarget()
        ac.targets.boss = ac.GetBoss(ac.range.basic)
    end
    if ac.IsTank() then
        ac.targets.boss = ac.GetBoss(ac.range.basic)
        ac.targets.cone = ac.GetMaxEnemiesInsideConePoint(ac.range.cone,false)
        ac.targets.long = ac.GetMobsInRange(ac.range.long,true)[1]
        ac.targets.single = ac.GetPrioritySingleTarget()
        ac.targets.short = ac.GetEnemiesInsideRadius(ac.range.short)
        ac.targets.tankpoke = ac.GetPriorityTankPoke()
    end
    if ac.IsHealer() then
        ac.targets.heal = ac.GetPrioritySingleHeal()
        ac.targets.rangecircle = ac.GetMaxEnemiesInsideRadiusRangePoint(5, ac.range.basic)
        ac.targets.revive = ac.GetPrioritySingleRevive()
        ac.targets.single = ac.GetPrioritySingleTarget()
        ac.targets.boss = ac.GetBoss(ac.range.basic)
    end
    if ac.IsCaster() then
        ac.targets.rangecircle = ac.GetMaxEnemiesInsideRadiusRangePoint(5, ac.range.basic)
        ac.targets.heal = ac.GetPrioritySingleHeal()
        ac.targets.revive = ac.GetPrioritySingleRevive()
        ac.targets.single = ac.GetPrioritySingleTarget()
        ac.targets.boss = ac.GetBoss(ac.range.basic)
    end
end
function ac.W2S(pos) return RenderManager:WorldToScreen(pos,true) end
RegisterEventHandler("Gameloop.Update", ac.Update, "EASECore")
RegisterEventHandler("Gameloop.Draw", ac.Draw, "EASECore")